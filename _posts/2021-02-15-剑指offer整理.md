---
layout:     post
title:      剑指offer整理
subtitle:   整理一下剑指offer解法
date:       2021-02-15
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 算法
---

# 剑指offer我的解法



### 10-1 斐波那契数列（动态规划）

​	状态转移方程：f(n) = f(n-1) +f(n-2);

~~~Java
class Solution{
    public int fib(int n){
        if(n == 0) return 0;
        if(n == 1) return 1;
        int first = 0，second = 1;
        int sum = 0;
        for(int i=2;i<=n;i++){
            sum = first + second;
            first = second;
            second = sum;
        }
        return sum;
    }
}
~~~

### 10-2 青蛙跳台阶（动态规划）

​	状态转移方程：f(n) = f(n-1) +f(n-2);

~~~java
class Solution{
    public int numways(int n){
        if(n == 0 || n==1) return 1;
        int first = 1,second = 1;
        int sum = 0;
        for(int i=2;i<=2;i++){
            sum = first + second;
            first = second;
            second = sum;
        }
        return sum;
    }
}
~~~

### 14-1 剪绳子、整数拆分乘积最大（动态规划、贪心算法）

最优解贪心：尽可能拆出3，次优2，最差1

~~~java
class Solution {
    public int cuttingRope(int n) {
        if(n == 2) return 1;
        if(n == 3) return 2;
        int a = n/3,b = n%3;
        if(b == 0) return (int)Math.pow(3,a);
        if(b == 1) return (int)Math.pow(3,a-1) * 4;
        return (int)Math.pow(3,a-1) * 6;
    }
}
~~~



### 19 正则表达式匹配



### 42 连续子数组的最大和（动态规划）

状态转移方程：![image-20210215141152079](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210215141152079.png)

​						优化：	dp[i] = max(dp[i-1],dp[i-1]+nums[i])

​										dp[i]为一定以i为结尾最大，但是不一定以i结尾最大，所以需要另一个max来记录最大值

~~~java
class Solution {
    public int maxSubArray(int[] nums) {
        int max  =nums[0];
        int cur = nums[0],pre = 0;
        for(int num : nums){
            cur = num;
            cur = Math.max(cur,cur+pre);
            max = Math.max(max,cur);
            pre = cur;
        }
        return max;
    }
}
~~~

### 63 买卖股票获取最大利润（动态规划）

状态转移方程：dp[i] = max(dp[i-1],nums[i]-low_price)

~~~java
class Solution {
    public int maxProfit(int[] prices) {
        int low_price = Integer.MAX_VALUE;
        int max = 0;
        for(int price : prices){
            low_price = Math.min(low_price,price);
            max = Math.max(max,price - low_price); 
        }
        return max;
    }
}
~~~

### 47 礼物的最大价值（动态规划）

状态转移方程：dp[i] = grid[i] [j] +max(dp[i-1] [j],dp[i] [j-1])

```java
class Solution {
    public int maxValue(int[][] grid) {
        int row = grid.length;
        int column = grid[0].length;
        int[][] dp = new int[row+1][column+1];
        

        for(int i=1;i<=row;i++){
            for(int j=1;j<=column;j++){
                dp[i][j] = grid[i-1][j-1] + Math.max(dp[i-1][j],dp[i][j-1]); 
            }
        }
        return dp[row][column];
    }
}
```



