---
layout:     post
title:      剑指offer整理
subtitle:   整理一下剑指offer解法
date:       2021-02-15
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 算法
---

# 剑指offer我的解法

### 6 从尾到头打印链表

~~~java
class Solution {
    public int[] reversePrint(ListNode head) {
        Stack<ListNode> stack = new Stack<>();
        ListNode temp = head;

        while(temp != null){
            stack.push(temp);
            temp = temp.next;
        }

        int size = stack.size();
        int[] res = new int[size];
        for(int i = 0;i < size; i++){
            res[i] = stack.pop().val;
        }

        return res;
    }
}
~~~



### 10-1 斐波那契数列（动态规划）

​	状态转移方程：f(n) = f(n-1) +f(n-2);

~~~Java
class Solution{
    public int fib(int n){
        if(n == 0) return 0;
        if(n == 1) return 1;
        int first = 0，second = 1;
        int sum = 0;
        for(int i=2;i<=n;i++){
            sum = first + second;
            first = second;
            second = sum;
        }
        return sum;
    }
}
~~~

### 10-2 青蛙跳台阶（动态规划）

​	状态转移方程：f(n) = f(n-1) +f(n-2);

~~~java
class Solution{
    public int numways(int n){
        if(n == 0 || n==1) return 1;
        int first = 1,second = 1;
        int sum = 0;
        for(int i=2;i<=2;i++){
            sum = first + second;
            first = second;
            second = sum;
        }
        return sum;
    }
}
~~~

### 14-1 剪绳子、整数拆分乘积最大（动态规划、贪心算法）

最优解贪心：尽可能拆出3，次优2，最差1

~~~java
class Solution {
    public int cuttingRope(int n) {
        if(n == 2) return 1;
        if(n == 3) return 2;
        int a = n/3,b = n%3;
        if(b == 0) return (int)Math.pow(3,a);
        if(b == 1) return (int)Math.pow(3,a-1) * 4;
        return (int)Math.pow(3,a-1) * 6;
    }
}
~~~

### 18 删除链表的结点

~~~java
class Solution{
    public ListNode deleteNode(ListNode head, int val){
        if(head.val == val) return head.next;
        ListNode pre = head;
        ListNode cur = head.next;

        while(cur != null && cur.val != val){
            pre = cur;
            cur = cur.next;
        }
        if(cur != null)
            pre.next = cur.next;
        return head;
    }
}
~~~



### 19 正则表达式匹配(动态规划)Hard

状态转移方程：![image-20210216143700056](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210216143700056.png)



~~~java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        boolean[][] f = new boolean[m + 1][n + 1];
        f[0][0] = true;
        for (int i = 0; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p.charAt(j - 1) == '*') {
                    f[i][j] = f[i][j - 2];
                    if (matches(s, p, i, j - 1)) {
                        f[i][j] = f[i][j] || f[i - 1][j];
                    }
                } else {
                    if (matches(s, p, i, j)) {
                        f[i][j] = f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }

    public boolean matches(String s, String p, int i, int j) {
        if (i == 0) {
            return false;
        }
        if (p.charAt(j - 1) == '.') {
            return true;
        }
        return s.charAt(i - 1) == p.charAt(j - 1);
    }
}
~~~

### 22 链表中倒数第k个结点（双指针）



~~~java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        if(head == null || k == 0) return null;
        ListNode former = head;
        ListNode latter = head;

        for(int i = 0; i < k; i++){
            if( former == null) return null;
            former = former.next;
        }

        while(former != null){
            former = former.next;
            latter = latter.next;
        }
        return latter;
    }
}
~~~



### 24 反转链表

~~~java
class Solution{
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;

        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
~~~

### 35 深拷贝带随机指针链表

~~~java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null ) return null;
        Node cur = head;

        //复制各节点
        while(cur != null){
            Node temp = new Node(cur.val);
            temp.next = cur.next;
            cur.next = temp;
            cur = temp.next;
        }

        //构建新节点的random
        cur =head;
        while(cur != null){
            if(cur.random != null)
                cur.next.random = cur.random.next;

            cur = cur.next.next;
        }

        //拆分两表
        cur = head.next;
        Node pre = head,res = head.next;
        while(cur.next != null){
            pre.next = pre.next.next;
            cur.next = cur.next.next;
            pre = pre.next;
            cur = cur.next;
        }
        //不加不行，不能改变原链表
        pre.next = null
        return res;
    }
}
~~~





### 42 连续子数组的最大和（动态规划）

状态转移方程：![image-20210215141152079](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210215141152079.png)

​						优化：	dp[i] = max(dp[i-1],dp[i-1]+nums[i])

​										dp[i]为一定以i为结尾最大，但是不一定以i结尾最大，所以需要另一个max来记录最大值

~~~java
class Solution {
    public int maxSubArray(int[] nums) {
        int max  =nums[0];
        int cur = nums[0],pre = 0;
        for(int num : nums){
            cur = num;
            cur = Math.max(cur,cur+pre);
            max = Math.max(max,cur);
            pre = cur;
        }
        return max;
    }
}
~~~

### 63 买卖股票获取最大利润（动态规划）

状态转移方程：dp[i] = max(dp[i-1],nums[i]-low_price)

~~~java
class Solution {
    public int maxProfit(int[] prices) {
        int low_price = Integer.MAX_VALUE;
        int max = 0;
        for(int price : prices){
            low_price = Math.min(low_price,price);
            max = Math.max(max,price - low_price); 
        }
        return max;
    }
}
~~~

### 47 礼物的最大价值（动态规划）

状态转移方程：dp[i] = grid[i] [j] +max(dp[i-1] [j],dp[i] [j-1])

```java
class Solution {
    public int maxValue(int[][] grid) {
        int row = grid.length;
        int column = grid[0].length;
        int[][] dp = new int[row+1][column+1];
        

        for(int i=1;i<=row;i++){
            for(int j=1;j<=column;j++){
                dp[i][j] = grid[i-1][j-1] + Math.max(dp[i-1][j],dp[i][j-1]); 
            }
        }
        return dp[row][column];
    }
}
```

### 52 两个链表的第一个公共结点

~~~java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode n1 = headA;
        ListNode n2 = headB;

        while(n1 != n2){
            n1 = n1 == null ? headB : n1.next;
            n2 = n2 == null ? headA : n2.next;
        }
        return n1;
    }
}
~~~



