---
layout:     post
title:      LeetCode刷题记录
subtitle:   概述
date:       2021-02-15
author:     QuanLi
header-img: img/post-bg-os-metro.jpg
catalog: true
tags:
    - 算法
---

# Leetcode刷题记录

### 46 全排列（回溯）

~~~java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        LinkedList<Integer> track = new LinkedList<>();
        backtrack(nums,track);
        return res;

    }

    public void backtrack(int[] nums,LinkedList<Integer> track){
        if(track.size() == nums.length){
            res.add(new LinkedList(track));
            return;
        }

        for(int i = 0; i < nums.length; i++){
            if(track.contains(nums[i])) continue;

            track.add(nums[i]);
            backtrack(nums,track);
            track.removeLast();
        }
    }
}
~~~



### 322 零钱兑换（动态规划）腾讯二面考到

状态转移方程：dp[i] = Math.min(dp[i],1 + dp[i - coin]);

一开始数组都初始化为amount + 1是因为凑成amount最多硬币数只能是amount个，设置成amount +1那么相当于无穷大，便于最后判断最后的能否凑成功，没凑出来便是amount +1,返回-1.

~~~java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //dp[i]表示当目标金额为i时，最少需要多少枚硬币
        int[] dp = new int[amount + 1];
        Arrays.fill(dp,amount + 1);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            for(int coin : coins){
                if(i < coin) continue;
                dp[i] = Math.min(dp[i],1 + dp[i - coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }
}
~~~



​	