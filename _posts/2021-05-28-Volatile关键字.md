---
layout:     post
title:      Volatile关键字
subtitle:   概述
date:       2021-05-28
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 多线程
---

# Volatile关键字

## 现代计算机内存模型

​	其实早期计算机中cpu和内存的速度是差不多的，但在现代计算机中，`cpu的指令速度远超内存的存取速度`，由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的`高速缓存（Cache）`来作为内存与处理器之间的缓冲。

​	基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：`缓存一致性（CacheCoherence）`。

​	在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。

![image-20210529000255866](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210529000255866.png)

## Java内存模型(JavaMemoryModel)

`	Java内存模型(JavaMemoryModel)`描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量，存储到内存和从内存中读取变量这样的底层细节。

### JMM有以下规定：

- 所有的**共享变量都存储于主内存**，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。

- **每一个线程还存在自己的工作内存**，线程的工作内存，**保留了被线程使用的变量的工作副本**。

- `线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量`。

- 不同线程之间也不能直接访问对方工作内存中的变量，**线程间变量的值的传递需要通过主内存中转来完成。**

volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。

### MESI（缓存一致性协议）

​	当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，**会发出信号通知其他CPU将该变量的缓存行置为无效状态**，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，**那么它就会从内存重新读取。**

#### 怎么发现数据是否失效呢？

**嗅探**

​	**每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了**，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

**嗅探的缺点**

​	由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值。

​	所以不要大量使用Volatile，至于什么时候去使用Volatile什么时候使用锁，根据场景区分。

## 禁止指令重排

​	为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。

### 重排序类型

![image-20210529001435321](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210529001435321.png)

在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。

一般重排序可以分为如下三种：

- **编译器优化的重排序。**编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;
- **指令级并行的重排序。**现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;
- **内存系统的重排序。**由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。

### volatile如何防止指令重排序

#### 内存屏障

​	java编译器会在生成指令系列时在适当的位置会插入`内存屏障`指令来禁止特定类型的处理器重排序。

​	为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：

![image-20210529003134031](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210529003134031.png)

需要注意的是：volatile写是在前面和后面**分别插入内存屏障**，而volatile读操作是在**后面插入两个内存屏障**。

#### 写

![image-20210529003217188](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210529003217188.png)

#### 读

![image-20210529003258299](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210529003258299.png)

上面的我提过重排序原则，为了提高处理速度，JVM会对代码进行编译优化，也就是指令重排序优化，并发编程下指令重排序会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。

如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。

从JDK5开始，提出了`happens-before`的概念，通过这个概念来阐述操作之间的内存可见性。

#### happens before

如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。

```
volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
```

如果现在我的变了flag变成了false，那么后面的那个操作，一定要知道我变了。

