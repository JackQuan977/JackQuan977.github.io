---
layout:     post
title:      OAuth2.0
subtitle:   概述
date:       2021-07-12
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - web
---

# OAuth2.0

### 简介

​	OAuth 是一个行业的标准授权协议，主要**用来授权第三方应用获取有限的权限**。实际上它就是一种授权机制，它的最终目的是**为第三方应用颁发一个有时效性的令牌 Token**，使得第三方应用能够通过该令牌获取相关的资源。

​	OAuth 2.0 比较常用的场景就是**第三方登录**，当你的网站接入了第三方登录的时候一般就是使用的 OAuth 2.0 协议。

###  OAuth 2.0 中的基本概念与授权流程

​	作为第三方登录服务提供方，其核心矛盾点是 **既要让用户在对接服务的 APP 上完成登录，同时还不能让该 APP 拿到用户的密码凭证** 。解决这一矛盾的利器就是 **token（中文译为令牌）**，而 OAuth 协议的最终目的就是给第三方应用下发 token，它记录了用户的登录或授权状态。通过将 token 下发给第三方应用，既能让 APP 登录并拿到用户许可的数据，也可以将用户的密码凭证牢牢拽在服务自己手里。

​	上面的论述可能侧重了第三方登录，实际上登录只是一个授权的过程，OAuth 2.0 协设计的目的在于开放授权。对于一个应用，其最终目的还是在于拿到用户存储在资源服务器上的用户数据，所以登录授权还只是第一步，后续 APP 还需要携带 token 去资源服务器请求用户数据，这个时候是一个鉴权的过程，OAuth 协议的主要目的在于授权，至于鉴权，实现上主要是还是对请求传递过来的 token 进行解析和验证，这一块相对要简单一些，所以本文主要讲解 OAuth 授权的过程。

### OAuth 2.0 定义的 4 种角色

- **资源所有者（resource owner）**

  受保护资源所属的实体，比如资源的所有人，下文的用户即为资源所有者。

- **资源服务器（resource server）**

  托管受保护资源的服务器，能够响应持有访问令牌的资源访问请求，可以与授权服务器是同一台服务器，也可以分开。

- **客户端（client）**

  客户端是 OAuth 服务的接入方，其目的是希望请求用户存储在资源服务器上的受保护资源。

- **授权服务器（authorization server）**

  授权服务器的主要职责是验证资源所有者的身份，并依据资源所有者的许可向客户端下发访问令牌。

### 基本概念

#### 访问令牌（access token）

​	授权服务器下发给客户端的一个授权凭证，该令牌所要表达的意思是“ **用户授予该 APP 在多少时间范围内允许访问哪些与自己相关的服务或数据** ”，所以访问令牌主要在 **时间范围** 和 **权限范围** 两个维度进行控制，此外访问令牌对于客户端来说是非透明的，外在表现就是一个字符串，客户端无法知晓字符串背后所隐藏的用户信息，因此不用担心用户的密码凭证会因此泄露。

#### 刷新令牌（refresh token）

​	刷新令牌的作用在于更新访问令牌，访问令牌的生命周期一般较短，这样可以保证在发生访问令牌泄露时，不至于造成太坏的影响，但是访问令牌有效期设置太短导致的副作用就是用户需要频繁授权，虽然可以通过一定的机制进行静默授权，但是频繁的调用授权接口之于授权服务器也是一种压力。此时可以在下发访问令牌的同时下发一个刷新令牌，刷新令牌的生命周期明显长于访问令牌，这样在访问令牌失效时，可以利用刷新令牌去授权服务器换取新的访问令牌，不过协议对于刷新令牌没有强制规定，是否需要该令牌客户端可以自行选择。

#### 回调地址（redirect uri）

​	OAuth 2.0 是一类基于回调的授权协议，以授权码模式为例，整个授权需要分为两步进行，第一步下发授权码，第二步根据授权码请求授权服务器下发访问令牌。OAuth 在第一步下发授权码时，是将授权码以参数的形式添加到回调地址后面，并以 302 跳转的形式进行下发，这样简化了客户端的操作，不需要再主动去触发一次请求，即可进入下一步流程。

​	回调的设计存在一定的安全隐患，坏人可以利用该机制引导用户到一个恶意站点，继而对用户发起攻击。对于授权服务器而言，也存在一定的危害，坏人可以利用该机制让授权服务器变成“肉鸡”，以授权服务器为代理请求目标地址，这样在消耗授权服务器资源的同时，也对目标地址服务器产生 DDOS 攻击。

​	为了避免上述安全隐患，OAuth 协议强制要求客户端在注册时填写自己的回调地址，其目的是为了让回调请求能够到达客户端自己的服务器，从而可以走获取访问令牌的流程。客户端可以同时配置多个回调地址，并在请求授权时携带一个地址，服务器会验证客户端传递上来的回调地址是否与之前注册的回调地址相同，或者前者是后者集合的一个元素，只有在满足这一条件下才允许下发授权码，同时协议还要求两步请求客户端携带的回调地址必须一致，通过这些措施来保证回调过程能够正常到达客户端自己的服务器，并继续后面拿授权码换取访问令牌的过程。

#### 权限范围（scope）

​	访问令牌自带过期时间，可以在时间维度上对授权进行控制，而在权限范围上，OAuth 引入了一个 scope 的概念。Scope 可以看做是一个对象，包含一个权限的 ID，名称，以及描述信息等，比如 “获取您的基本资料（头像、昵称）”。应该在接入 OAuth 服务时必须向服务提供方申请相应的 scope，并在请求授权时指明该参数，这些权限在用户确认授权时，必须毫无保留的展示给用户，以让用户知道本次请求需要访问用户的哪些数据或服务。

### 基本授权流程

​	OAuth 2.0 协议定义了 4 种授权模式，其中最具代表性的是授权码模式，我们将在 3.1 节中详细介绍，这里先简单体会一下 OAuth 2.0 的授权流程，交互时序图如下：

![image-20210718132016193](https://i.loli.net/2021/07/18/7j3G5maqHwVl69Q.png)

假设整个流程开始之前，用户已经登录，那么整个授权流程如下：

1. 客户端请求资源所有者（用户）授权，一般都是由授权服务器进行引导

2. 资源所有者实施授权（采用 4 种授权模式中的一种），客户端拿到用户的授权凭证

3. 客户端携带用户授权凭证请求授权服务器下发访问令牌

4. 授权服务器验证客户端出示的授权凭证，并下发访问令牌

5. 客户端携带访问令牌请求存储在资源服务器上的用户受保护资源

6. 资源服务器验证客户端出示的访问令牌，通过则响应客户端的请求

   整个过程中，客户端都无法接触到用户的密码凭证信息，客户端通过访问令牌请求受保护资源，用户可以通过对授权操作的控制来间接控制客户端对于受保护资源的访问权限范围和周期。

## 授权模式

OAuth 2.0 相对于 1.0 版本在授权模式上做了更多的细化，已定义的授权模式分为四种：

1. 授权码模式（Authorization Code Grant）
2. 隐式授权模式（Implicit Grant）
3. 资源所有者密码凭证模式（Resource Owner Password Credentials Grant）
4. 客户端凭证模式（Client Credentials Grant）

### 授权码授权模式（Authorization Code Grant）

​	授权码模式在整个授权流程上与 1.0 版本最为贴近，但是流程上还是要简化许多，也是 OAuth 2.0 中最标准，应用最为广泛的授权模式。这类授权模式非常适用于具备服务端的应用，当然现在大多数 APP 都有自己的服务端，所以授权码模式拥有最广泛的应用场景，下图为授权码各个角色之间的交互时序：

![image-20210718133032192](https://i.loli.net/2021/07/18/clLPqad61uYe3FO.png)

整个授权流程说明如下（具体参数释义见下文）：

1. 客户端携带 client_id, scope, redirect_uri, state 等信息请求授权服务器下发 code
2. 授权服务器验证客户端身份，通过则询问用户是否同意授权（此时会跳转到用户能够直观看到的授权页面，等待用户点击确认授权）
3. **假设用户同意授权，此时授权服务器会将 code 和 state 拼接在 redirect_uri 后面，并以 302 形式下发 code**
4. 客户端携带 code, redirect_uri, 以及 client_secret 请求授权服务器下发 access_token
5. 授权服务器验证客户端身份，同时验证 code，以及 redirect_uri 是否与第一步相同，通过则下发 access_token，并选择性下发 refresh_token

#### 获取授权码

​	授权码是授权流程的一个中间临时凭证，是对用户确认授权这一操作的一个短暂性表征，其生命周期一般较短，协议建议最大不要超过 10 分钟，在这一有效时间内，客户端可以通过授权码去授权服务器请求换取访问令牌，授权码应该采取防重放措施。

**请求参数说明：**

![image-20210718133734394](https://i.loli.net/2021/07/18/NEuTxKjtZc8d31e.png)

```
GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1  
Host: server.example.com
```

​	客户端携带上述参数请求授权服务器，授权服务器会验证客户端的身份以及相关参数，并在确认用户已登录的前提下弹出授权页询问用户是否同意授权，如果用户同意则会将授权码（code）和 state 信息添加到回调地址后面，并以 302 的形式下发。

**成功响应参数说明：**

![image-20210718133839148](https://i.loli.net/2021/07/18/HVaJYbB5rjFiMCg.png)

**成功响应示例：**

```
HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&state=xyz
```

#### 下发访问令牌

​	授权服务器的授权端点在以 302 形式下发 code 之后，用户 User-Agent，比如浏览器，将携带对应的 code 回调请求用户指定的 redirect_url，这个地址应该能够保证请求打到应用服务器的对应接口，该接口可以由此拿到 code，并附加相应参数请求授权服务器的令牌端点，授权端点验证 code 和相关参数，验证通过则下发 access_token。

#### 对于授权码模式的一点小感悟

​	授权码授权模式是 OAuth 2.0 协议已定义 4 种模式中最严谨的模式，其余 3 中模式都是建立在一些特殊场景下，并对这些场景做了一些妥协和优化。授权码授权流程分为两步走，将用户授权与下发访问令牌分开，这给授权带来了更多的灵活性，正常授权过程中必须经过用户登录这一步骤，在用户已登录的前提下，可以直接询问用户是否同意授权，但是在一些场景下，比如内部走 SSO（单点登录）的应用集成了基于 OAuth 授权的第三方应用，这个时候在 OAuth 授权登录第三方应用时，用户体验较好的流程是不需要用户再次输入用户名和密码的，这就需要将外围 APP 的登录态传递给嵌套的应用，但是这样是存在安全问题的，用户的登录态必须把握在走 SSO 登录流程的应用手上，这样的场景下授权码授权模式的两步走流程就可以满足在不交出用户登录态的情况下，无需再次登录即可授权。

​	内部应用可以拿着第三方应用的 client_id 等信息代替第三方应用去请求获取 code，因为自己持有用户的登录态，所以过程中无需用户再次输入用户名和密码，拿到 code 之后将其交给第三方应用，第三方应用利用 code 和自己的 client_secret 信息去请求授权服务器下发 token，整个流程内部应用不需要交出自己持有的用户登录态，第三方应用也无需交出自己的 client_secret 信息，最终却能够实现在保护用户密码凭证的前提下无需再次登录即可完成整个授权流程。
