---
layout:     post
title:      MySQL的锁
subtitle:   概述
date:       2021-04-20
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 数据库
---

# MySQL的锁

​	MySQL锁的分类有很多种，一大堆东西和名词，所以做一次整理。

![image-20210420202512120](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210420202512120.png)

### 为什么需要学习数据库锁知识

不少人在开发的时候，应该**很少会注意到**这些锁的问题，也很少会给程序加锁(除了**库存**这些对数量准确性要求极高的情况下)

一般也就听过常说的乐观锁和悲观锁，了解过基本的含义之后就没了~~~

**定心丸**：即使我们不会这些锁知识，我们的程序在**一般情况下**还是可以跑得好好的。因为这些锁数据库**隐式**帮我们加了

- **MyISAM**在执行查询语句`SELECT`前，会**自动**给涉及的所有表加**读锁**，在执行更新操作（`UPDATE、DELETE、INSERT`等）前，会**自动**给涉及的表加**写锁**，这个过程并**不需要用户干预**

只会在某些特定的场景下才需要**手动**加锁，学习数据库锁知识就是为了:

- 能让我们在特定的场景下派得上用场
- 更好**把控自己写的程序**
- 在跟别人聊数据库技术的时候可以搭上几句话
- **构建自己的知识库体系**！在面试的时候不虚

### 表锁细讲

首先，从锁的粒度，我们可以分成两大类：

- **表锁**，不会发生死锁，锁粒度大，发生冲突概率高，并发度最低
- **行锁**，会出现死锁，锁粒度小，发生冲突概率低，并发度最高

不同的存储引擎支持的锁粒度是不一样的：

- **InnoDB行锁和表锁都支持**！
- **MyISAM只支持表锁**！

InnoDB只有通过**索引条件**检索数据**才使用行级锁**，否则，InnoDB将使用**表锁**

- 也就是说，**InnoDB的行锁是基于索引的**！

**表锁下又分为两种模式**：

- 表读锁（Table Read Lock）

- 表写锁（Table Write Lock）

- 从下图可以清晰看到，在表读锁和表写锁的环境下：

  ​	**读读不阻塞，读写阻塞，写写阻塞！**

  - 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁
  - 读写阻塞：当前用户在读数据，其他的用户**不能修改当前用户读的数据**，会加锁！
  - 写写阻塞：当前用户在修改数据，其他的用户**不能修改当前用户正在修改的数据**，会加锁！



![image-20210420205214512](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210420205214512.png)

从上面已经看到了：**读锁和写锁是互斥的，读写操作是串行**。

### 行锁细讲

​	上边简单讲解了表锁的相关知识，我们使用Mysql一般是使用InnoDB存储引擎的。InnoDB和MyISAM有两个本质的区别：

- InnoDB支持行锁
- InnoDB支持事务

从上面也说了：我们是**很少手动加表锁**的。表锁对我们程序员来说几乎是透明的，即使InnoDB不走索引，加的表锁也是自动的！

我们应该**更加关注行锁的内容**，因为InnoDB一大特性就是支持行锁！

InnoDB实现了以下**两种**类型的行锁。

- 共享锁（S锁），叫做**读锁**：读锁是**共享**的，多个客户可以**同时读取同一个**资源，但**不允许其他客户修改**。
- 排他锁（X锁)，也叫**写锁**：写锁是排他的，**写锁会阻塞其他的写锁和读锁**。

### 乐观锁和悲观锁

​	乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。

​	悲观锁是数据库层面加锁，都会阻塞去等待锁


#### 悲观锁

我们使用悲观锁的话其实很简单(手动加行锁就行了)：

- `select * from xxxx for update`

在select 语句后边加了 `for update`相当于加了排它锁(写锁)，加了写锁以后，其他的事务就不能对它修改了！需要等待当前事务修改完之后才可以修改.也就是说，如果张三使用`select ... for update`，李四就无法对该条记录修改了~

#### 乐观锁

乐观锁不是数据库层面上的锁，是需要自己**手动去加的锁**。一般我们添加一个版本字段来实现：

具体过程是这样的：

张三`select * from table` --->会查询出记录出来，同时会有一个version字段

![image-20210420213212613](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210420213212613.png)

李四`select * from table` --->会查询出记录出来，同时会有一个version字段

![image-20210420213245464](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210420213245464.png)

李四对这条记录做修改：`update A set Name=lisi,version=version+1 where ID=#{id} and version=#{version}`，判断之前查询到的version与现在的数据的version进行比较，**同时会更新version字段**

此时数据库记录如下：

![image-20210420213420193](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210420213420193.png)

张三也对这条记录修改：`update A set Name=lisi,version=version+1 where ID=#{id} and version=#{version}`，但失败了！因为**当前数据库中的版本跟查询出来的版本不一致**！

![image-20210420213500240](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210420213500240.png)#

### 间隙锁

​	当我们**用范围条件检索数据**而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给**符合范围条件的已有数据记录的索引项加锁**；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。

值得注意的是：间隙锁只会在`Repeatable read`隔离级别下使用~

例子：假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101

```
Select * from  emp where empid > 100 for update;
```

上面是一个范围查询，InnoDB**不仅**会对符合条件的empid值为101的记录加锁，也会对**empid大于101（这些记录并不存在）的“间隙”加锁**。

InnoDB使用间隙锁的目的是：

- **为了防止幻读**(上面也说了，`Repeatable read`隔离级别下再通过GAP锁即可避免了幻读)

### 死锁

并发的问题就少不了死锁，在MySQL中同样会存在死锁的问题。

但一般来说MySQL通过回滚帮我们解决了不少死锁的问题了，但死锁是无法完全避免的，可以通过以下的经验参考，来尽可能少遇到死锁：

- 以**固定的顺序**访问表和行。比如对两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；将两个事务的sql顺序调整为一致，也能避免死锁
- **大事务拆小**。大事务更倾向于死锁，如果业务允许，将大事务拆小。
- 在同一个事务中，尽可能做到**一次锁定**所需要的所有资源，减少死锁概率。
- **降低隔离级别**。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
- **为表添加合理的索引**。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

### 总结

上面说了一大堆关于MySQL数据库锁的东西，现在来简单总结一下。

表锁其实我们程序员是很少关心它的：

- 在MyISAM存储引擎中，当执行SQL语句的时候是自动加的。
- 在InnoDB存储引擎中，如果没有使用索引，表锁也是自动加的。

现在我们大多数使用MySQL都是使用InnoDB，InnoDB支持行锁：

- 共享锁--读锁--S锁
- 排它锁--写锁--X锁

在默认的情况下，`select`是不加任何行锁的~事务可以通过以下语句显示给记录集加共享锁或排他锁。

- 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`。
- 排他锁（X)：`SELECT * FROM table_name WHERE ... FOR UPDATE`。

InnoDB**基于行锁**还实现了MVCC多版本并发控制，MVCC在隔离级别下的`Read committed`和`Repeatable read`下工作。MVCC能够实现**读写不阻塞**！

InnoDB实现的`Repeatable read`隔离级别配合GAP间隙锁已经避免了幻读！

- 乐观锁其实是一种思想，正如其名：认为不会锁定的情况下去更新数据，如果发现不对劲，才不更新(回滚)。在数据库中往往添加一个version字段来实现。
- 悲观锁用的就是数据库的行锁，认为数据库会发生并发冲突，直接上来就把数据锁住，其他事务不能修改，直至提交了当前事务