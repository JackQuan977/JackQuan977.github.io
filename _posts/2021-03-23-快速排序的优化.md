---
layout:     post
title:      快速排序的优化
subtitle:   概述
date:       2021-03-23
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 算法
---

### 快速排序的优化

### 快速排序思想

​	选一个支点，保证支点左边的比支点小，支点右边的比支点大，然后对支点左右两边进行递归，使整个序列有序。快排最坏情况下，也就是每次都选的最大或者最小值，时间复杂度为O(n^2)。平均和最好时间复杂度均为O(nlogn);

### 普通快速排序的性能问题

​	快排最关键的地方在于如何选择支点，最好的情况是每次选择的支点都是中间值，这样正好分成两半，但这太理想了。最坏情况是每次都正好选择最大最小值，那样时间复杂度就是O(n^2)。对于快排来说，如果原本有序，又选择第一个或者最后一个元素作为支点的话，性能极差，部分有序同理，所以快排越无序越快。

### 优化方法之三数取中选择支点

​	因为**最理想状况下每次选择支点正好都是中间值的话性能最好**，但是我们又不可能每次都正好取到中间值，那么我们可以想一个折中的方法，一般我们可以选最左，中间，最右三个元素这三个数，取这三个数排序的中间值作为支点。

~~~java
/*函数作用：取待排序序列中low、mid、high三个位置上数据，选取他们中间的那个数据作为枢轴*/
int SelectPivotMedianOfThree(int arr[],int low,int high)
{
	int mid = low + ((high - low) >> 1);//计算数组中间的元素的下标
 
	//使用三数取中法选择枢轴
	if (arr[mid] > arr[high])//目标: arr[mid] <= arr[high]
	{
		swap(arr[mid],arr[high]);
	}
	if (arr[low] > arr[high])//目标: arr[low] <= arr[high]
	{
		swap(arr[low],arr[high]);
	}
	if (arr[mid] > arr[low]) //目标: arr[low] >= arr[mid]
	{
		swap(arr[mid],arr[low]);
	}
	//此时，arr[mid] <= arr[low] <= arr[high]
	return arr[low];
	//low的位置上保存这三个位置中间的值
	//分割时可以直接使用low位置的元素作为枢轴，而不用改变分割函数了
}
~~~

### 优化方法之使用插入排序

当序列长度分割到一定长度，大概10左右使用插入排序。

原因：对于很小和部分有序的数组，插入排序性能要比快排好，此时可以用插入排序而不是快排

~~~java
if (high - low + 1 < 10)
{
	InsertSort(arr,low,high);
	return;
}//else时，正常执行快排
~~~

### 优化方法之聚集相等元素

​	在一次分割后，把与pivot相等的元素聚集在一起，下次再分割时，不再对这些元素分割

举例：

待排序序列 1 4 6 7 6 6 7 6 8 6

三数取中选取枢轴：下标为4的数6

本次划分后，未对与key元素相等处理的结果：1 4 6 6 7 6 7 6 8 6

如果聚集相等元素效率会更高

- 在第一步划分过程中，把与pivot相等元素放入数组两端
- 划分结束后，将相等元素移动到pivot周围

### 总结

可以把这三种方法结合起来：**三数取中+插排+聚集相等元素**，效率很高

