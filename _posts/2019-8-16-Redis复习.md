---
layout:     post
title:      Redis复习(持续更新)
subtitle:   概述
date:       2019-8-16
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - Redis
    - 数据库
---

# Redis

### Redis为什么这么快

​	Redis 作为一个内存数据库，它需要处理很多来自外部的网络请求，它使用 **I/O 多路复用机制**同时监听多个客户端连接的可读和可写状态，一旦收到网络请求就会在内存中快速处理，由于绝大多数的操作都是纯内存的，所以处理的速度会非常地快。

### 什么是文件事件处理器

文件事件就是客户端进行读取写入操作，设计一系列网络通信。Redis文件事件处理器使用IO多路复用技术同时监听多个套接字，根据套接字目前执行的任务来为套接字关联不同的事件处理器。

### Redis为什么最初选择单线程

- 使用单线程模型能带来更好的可维护性，不用考虑线程安全的问题，方便开发和调试；
- 使用单线程模型也能并发的处理客户端的请求，但是它却使用 I/O 多路复用机制**并发**处理来自客户端的多个连接，同时等待多个连接发送的请求。
- 如果这种吞吐量不能满足我们的需求，更推荐的做法是使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。
- Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O

### 为什么4.0后引入多线程

​	**Redis4.0引入多线程主要是针对一些大键值对的异步删除操作命令**， 6.0的多线程主要是为了提升网络IO读写性能。执行命令仍然是单线程。

​	Redis 在最新的几个版本中加入了一些**可以被其他线程异步处理的删除操作**，我们可以在 Redis 在中使用 `DEL` 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是**同步地**删除这些键值对也不会消耗太多的时间。

​	但是对于 Redis 中的一些**超大键值对**，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，**这些操作就会阻塞待处理的任务**，然而释放内存空间的工作其实可以由后台线程异步进行处理，这也就是 `UNLINK` 命令的实现原理，它只会将键从元数据中删除，真正的删除操作会在后台异步执行。

### 过期的数据的删除策略

- 惰性删除：在取出key时才对数据进行过期检查，这样对CPU最好
- 定期删除：每隔一段时间抽取出一批key执行删除过期key,Redis底层会限制删除时长和频率减少对CPU的影响，定期删除对内存更友好。

惰性删除对CPU友好，定期删除对内存友好，两者各有千秋，所以Redis采用两种方式结合方式

### Redis内存淘汰机制

定期删除和惰性删除还是会漏掉很多过期key，所以需要内存淘汰机制

- lru(最常用）：移除最近最少用
- random:  任意选择数据淘汰
-  ttl: 从已设置过期时间的数据集中选将要过期的数据淘汰
-  lfu：移除最不经常使用

### 分布式缓存常见的技术选型方案有哪些 ？

###  说一下 **Redis** 和 **Memcached** 的区 别 和 共 同 点 

##### 共同点

- 都是基于内存的数据库性能很好，一般都用作缓存
- 都有过期策略

##### 区别

- Redis支持更丰富的数据类型，memcached只支持最简单的k/v
- Redis支持数据持久化，有灾难恢复机制，可以将内存中的数据保存在磁盘中，重启时可以再次加载使用，而memcached不支持持久化
- Redis在服务器内存满了的时候，可以将不用的数据放到磁盘上，memcached内存满直接报异常
- Redis原生支持集群
- memcached是多线程，非阻塞IO复用网络模型。Redis使用单线程的IO多路复用
- memcached过期数据删除采用惰性删除，Redis同时使用惰性删除和定期删除

###  Redis持久化机制

- 快照持久化**RDB**：创建快照存储在内存里面数据在某个时间点上的副本。是Redis默认持久化方式
- 追加文件持久化**AOF**：与RDB相比，AOF实时性更好，开启AOF后每执行一条更改数据命令Redis就会将该命令写入AOF文件。

### 说一下有缓存情况下查询数据和修改数据的流程。

### **Redis** 有哪些数据结构？ **SDS** 了 解 么 ？

- 简单动态字符串（string)：简单的key-value类型，不仅可以保存文本数据还可以保存二进制数据，常用于计数场景，点赞评论转发数
- 链表（list）：Redis的链表是一个双向链表，常用于消息队列，慢查询
- hash:类似于java的HashMap,特别适合存储对象
- set,类似java的HashSet,可以基于set轻易实现交集并集，可以用来实现共同关注、共同粉丝、共同喜好等功能
- sorted set，和set相比增加权重参数，使集合有序，排行榜，弹幕等

### Redis 内存满了怎么办？

### Redis 内存淘汰算法除了 LRU 还有哪些？ 

### Redis 给缓存数据设置过期时间有啥用？Redis 是如何判断数据是否过期的 呢？ 

### Redis 事务了解么？(Redis 可以通过 **MULTI**， **EXEC**， **DISCARD** 和 **WATCH** 等命令来实现事务功能)

### 缓 存 穿 透 和 缓 存 雪 崩 问 题 了 解 么 ？ 有 哪 些 解 决 办 法 ？

- **缓存穿透**：请求的大量key不在缓存中，请求直接到了数据库。

  **解决方法**

  - 做好基本参数校验，一些不合法的参数请求直接返回给用户
  - 布隆过滤器：所有可能请求都放在布隆过滤器，用户请求过来先判断请求值在不在布隆过滤器，存在才会接着走下面流程

- **缓存雪崩**：缓存在同一时间大面积失效，请求直接落在数据库

  **解决方法**

  - 采用Redis集群
  - 限流

### 如何保证缓存和数据库一致性



### 如何基于 Redis 实现分布式锁？

