---
l ayout:     post
title:      重点算法题记录
subtitle:   概述
date:       2021-02-20
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 算法
---

# 重点算法题记录

**不能一次性流畅写对=面试写不出来=没做过！**

### 单例DCL

~~~java
public class Singleton1 {
    public static void main(String[] args) {
        Singleton1 instance1 = Singleton1.getInstance();
        Singleton1 instance2 = Singleton1.getInstance();
        System.out.println(instance1 == instance2);
    }
    private Singleton1(){}
    private static volatile Singleton1 instance;
    public static Singleton1 getInstance(){
        if(instance == null){
            synchronized (Singleton1.class){
                if(instance == null){
                    instance = new Singleton1();
                }
            }
        }
        return instance;
    }
}
~~~

### 单例懒汉

~~~java
public class Singleton2 {
    private Singleton2(){}
    private static Singleton2 instance = new Singleton2();
    public static Singleton2 getInstance(){
        return instance;
    }
}

~~~

### 单例静态内部类

~~~java
public class Singleton3 {
    private Singleton3(){}
    private static class SingletonInstance{
        private static final Singleton3 instance = new Singleton3();
    }

    public static Singleton3 getInstance(){
        return SingletonInstance.instance;
    }
}
~~~

### 单例枚举

~~~java
public class Singleton4{
    private Singleton4(){}
    
    private enum SingletonInstance{
        INSTANCE;
        private final Singleton4 instance;
		SingletonInstance(){
            instance = new Singleton4();
        }
        
        private Singleton4 getInstance(){
            return instance;
        }
    }
    
    public static Singleton4 getInstance(){
        return SingletonInstance.INSTANCE.getInstance();
    }
}
~~~



###  快速排序*

~~~java
 public static void quickSort(int[] nums, int L, int R) {
        int i = L;
        int j = R;
        int pivot = nums[(L + R) / 2];

        while (i <= j) {
            while (nums[i] < pivot) {
                i++;
            }

            while (nums[j] > pivot) {
                j--;
            }

            if (i <= j) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
                j--;
            }
        }
        if (L < j)
            quickSort(nums, L, j);
        if (i < R)
            quickSort(nums, i, R);
    }
~~~

### 优化的冒泡排序

思路：

- 外层循环控制比较趟数，内层循环控制每次比较交换次数，外层循环是从0开始计数所以是i < nums.length - 1;，内层循环要交换nums[j] 和 nums[j + 1]也要多预留一个，所以j < nums.length - i - 1
- 添加一个控制位，在已有序时提前退出

~~~java
    public static void bubbleSort(int[] nums){
        int isChange;
        //外层循环控制循环趟数
        for(int i = 0; i < nums.length - 1; i++){
            isChange = 0;
            for (int j = 0; j < nums.length - i - 1; j++){
                if(nums[j] > nums[j + 1]){
                    int temp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = temp;
                    isChange = 1;
                }
            }
            if(isChange == 0) break;
        }
    }
~~~



### 堆排

- 堆排首先写一个辅助函数swap，因为后面建堆要交换，堆排后也要交换数组中第一个和最后一个
- 然后写一个maxHeapify函数，负责在左右子树已经是堆的情况下建堆
- 然后自下至上建堆

- heapSize = nums.length
- l < heapsize && arrs[l] > arrs[max],判断越界要在前面，防止溢出

~~~java
public class HeapSort {

    public static void main(String[] args) {
        int[] arrs = {1,342,42,534,5,453,11,2,2,3453,451,14};
        heapSort(arrs);
        for(int i = 0; i < arrs.length; i++){
            System.out.println(arrs[i]);
        }
    }

    public static void heapSort(int[] arrs){
        int heapsize = arrs.length;
        buildMaxHeapify(arrs,heapsize);
        for(int i = arrs.length - 1; i >= 0; i--) {
            swap(arrs, 0, i);
            heapsize--;
            maxHeapify(arrs, 0, heapsize);
        }
    }

    public static void buildMaxHeapify(int[] arrs, int heapsize){
        for(int i = arrs.length / 2 - 1; i >= 0; i--){
            maxHeapify(arrs, i, heapsize);
        }
    }

    public static void maxHeapify(int[] arrs, int curRoot, int heapsize){
        int l = curRoot * 2 + 1, r = curRoot * 2 + 2;
        int max = curRoot;
        //注意l < heapsize一定要放在前面不然会报错，这是短路原则不提前判断索引越界
        if(l < heapsize && arrs[l] > arrs[max])
            max = l;
        if(r < heapsize && arrs[r] > arrs[max])
            max = r;
        if (curRoot != max){
            swap(arrs, max, curRoot);
            maxHeapify(arrs, max, heapsize);
        }
    }

    public static void swap(int[] arrs, int i, int j){
        int temp = arrs[i];
        arrs[i] = arrs[j];
        arrs[j] = temp;
    }
}

~~~



### 归并排序

~~~java

~~~



### 手写生产者消费者

### 二分查找

leetcode 704

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

~~~java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target ){
                return mid;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else if(nums[mid] > target){
                right = mid - 1;
            }
        }
        return -1;
    }
}
~~~

### 二叉树前序遍历！！！

leetcode  144

**递归：**

~~~java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new  ArrayList<>();
        preOrder(root,res);
        return res;
    }

    public void preOrder(TreeNode root,List<Integer> res){
        if(root == null) return;
        res.add(root.val);
        preOrder(root.left,res);
        preOrder(root.right,res);
    }
}
~~~

非递归：

思路：

- 使用栈的辅助空间，将root.left依次压入栈中，不管是前中后都是这么操作，因为不管是前中后遍历都要从左边开始，中间过程可以根据前中后的特点给res添加值，前序遍历是在向栈中添加root.left的过程中就添加结果值。
- 然后再将root.left从栈中依次取出

~~~java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Deque<TreeNode> stack = new LinkedList<>();

        while(!stack.isEmpty() || root != null){
            while(root != null){
                res.add(root.val);
                stack.push(root);
                root = root.left;
            }
            //这时候root=null了
            root = stack.pop();
            root = root.right;
        }
        return res;
    }
}
~~~



### 二叉树的中序遍历

leetcode 94

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。递归很简单，面试肯定考察非递归。

思路：

- 中序遍历是左中右，先将所有root.left依次压入栈，依次弹出栈，那么就实现了左中，其中如果遇到有右结点的再令root = root.right,不断迭代，最后就是中序遍历

- 空间复杂度o(n)，还有一个莫里斯法空间复杂度o(1) 

**非递归写法**：

~~~java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> stk = new Stack<>();
        //这个条件很精髓
        while(root != null || !stk.isEmpty()){
            while(root != null){
                stk.push(root);
                root = root.left;
            }

            root = stk.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
}
~~~

**递归写法：**

~~~java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root,res);
        return res;
    }

    public void inorder(TreeNode root,List<Integer> res){
        if(root == null) return;
        inorder(root.left,res);
        res.add(root.val);
        inorder(root.right,res);
    }
}
~~~

### 二叉树的后序遍历！！！！！！！！！

leetcode 145

**递归：**

~~~java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postOrder(root,res);
        return res;

    }
    public void postOrder(TreeNode root,List<Integer> res){
        if(root == null) return;
        postOrder(root.left,res);
        postOrder(root.right,res);
        res.add(root.val);
    }
}
~~~

**非递归：**

~~~java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if(root == null) return res;
        Deque<TreeNode> stack = new LinkedList<>();
        // pre结点包括它的左右子节点都已经被add过
        TreeNode pre = null;

        while(root != null || !stack.isEmpty()){
            while(root != null){
                stack.push(root);
                root = root.left;
            }

            root = stack.pop();
            if(root.right == null || root.right == pre){
                res.add(root.val);
                pre = root;
                //root的左右都已经被遍历过了，给他null防止再次迭代在栈中加入其左子节点
                root = null;
            }else{
                //右子树不为空，再次把根结点压入
                stack.push(root);
                root = root.right;
            }

        }
        return res;
    }
}
~~~



### 反转链表

剑指offer 24 leetcode 206

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

思路：用两个指针迭代，遍历链表，遍历的时候偶反转两个节点

~~~java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null,cur = head;
        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
~~~

### 反转链表2！！！

leetcode 92

反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转。

~~~
说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
~~~

思路：

- 设立一个dummy结点，方便最后返回结果
- 和反转链表一样，设立pre和cur两个指针，然后将cur移动到待翻转的第一个位置，将pre移动到cur前一个结点，然后用right - left范围的for循环控制反转链表的范围
- 使用头插法，就是删除cur节点后一个结点，然后将这个结点插入cur结点前面，每后一个都插入到最前，就将链表反转了
- 注意left第一个结点是从1开始算的

~~~java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode pre = dummy;
        ListNode cur = dummy.next;

        for(int i = 0; i < left - 1; i++){
            pre = pre.next;
            cur = cur.next;
        }

        for(int i = 0; i < right - left; i++){
            ListNode removed = cur.next;
            cur.next = cur.next.next;

            removed.next = pre.next;
            pre.next = removed;
        }
        return dummy.next;
    }
}
~~~



### 数组中的第k个最大元素

leetcode 215

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。即排序后从后往前第k个，相当于索引nums.length - k

思路：大顶堆，删除堆顶k-1次，最后的堆顶就是我们要的结果

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

~~~java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeapify(nums,heapSize);
        for(int i = nums.length - 1; i >= nums.length - k + 1; i--){
            swap(nums, 0 , i);
            heapSize--;
            //交换完了堆顺序就不对了，以0为根根正一次
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }
	//从左到右，从上到下，用maxHeapify建堆
    public void buildMaxHeapify(int[] nums, int heapSize){
        //第一个非叶子结点是nums.length / 2 - 1
        for(int i = nums.length / 2 - 1; i >= 0; i--){
            maxHeapify(nums, i, heapSize);
        }
    }
	//这个函数作用是假定左右子节点已经是堆了
    public void maxHeapify(int[] nums, int curRoot, int heapSize){
        int l = curRoot * 2 + 1, r = curRoot * 2 + 2;
        int max = curRoot;
        if(l < heapSize && nums[l] > nums[max])
            max = l;

        if(r < heapSize && nums[r] > nums[max])
            max = r;

        if(max != curRoot){
            swap(nums,max,curRoot);
            maxHeapify(nums, max, heapSize);
        }
        
    } 
    //交换数组中对应值
    public void swap(int[] nums, int i , int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
~~~

### 每k个反转链表！！！

leetcode 25

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

~~~java
示例：

给你这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5
~~~



思路：

- 每次翻转前，要确定翻转链表的范围，这个必须通过 `k` 此循环来确定
- 需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来
- 初始需要两个变量 `pre` 和 `end`，`pre` 代表待翻转链表的前驱，`end` 代表待翻转链表的末尾
- 经过k此循环，`end` 到达末尾，记录待翻转链表的后继 `next = end.next`
- 翻转链表，然后将三部分链表连接起来，然后重置 `pre` 和 `end` 指针，然后进入下一次循环
- 特殊情况，当翻转部分长度不足 `k` 时，在定位 `end` 完成后，`end==null`，已经到达末尾，说明题目已完成，直接返回即可
- 反转链表2可以精确控制次数所以不用断开连接

~~~java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        //别忘了吧dummy和head连起来
        dummy.next = head;
        //pre指向待翻转头结点前一个，end指向待翻转最后一个
        ListNode pre = dummy;
        ListNode end = dummy;
        //end找到每次要翻转的末尾
        while(end.next != null){
            for(int i = 0;i < k && end != null; i++) end = end.next;
            if(end == null) break;
            ListNode start = pre.next;
            ListNode next = end.next;
            //别忘了断开连接再反转链表，注意这里不能是next = null 这样代表end的下一个结点为空，但是不代表逻辑上断开的操作，不断开连接会一直反转到最后
            end.next = null;
            pre.next = reverse(start);
            start.next = next;
            //重新开始新循环，pre和end跳到待翻转
            pre = start;
            end =start;
        }
        return dummy.next;
    }

    //反转链表
    public ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode cur = head;

        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
~~~

### LRU！！！

leetcode 146

https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/

实现 LRUCache 类：

LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。



思路：![image-20210226172625052](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210226172625052.png)

- 哈希表+双向链表，借助哈希表，可以通过key快速映射到任何一个链表结点，然后进行插入删除，**实现时间O(1)**，也就是用空间换时间嘛

- 双向链表中规定靠近头部是最近使用的，靠近尾部是最近未使用的

- 小技巧：在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在，也方便添加删除头尾结点

- get操作：

  - 如果key不存在返回-1
  - 如果key存在，则key对应节点为最近被使用的结点。通过哈希表定位到它在双向链表中的位置，然后把这个结点移到双向链表的头部，最后返回该结点的值

  

- put操作：
  - 如果key不存在，使用key和value创建一个新节点，在双向链表头部添加该结点，然后将key和该结点加入哈希表。然后判断双向链表的容量是不是超了，超了删除尾结点，并删掉哈希表对应值
  - 如果key存在，先通过哈希表定位，再将对应值更新为value,然后移到链表头部
  
- LRU需要四个辅助函数，分别是addFirst将结点放到第一个；deleteNode删除一个结点；moveFirst将节点放到第一个，这个可以调用前两个，先删除再放到第一个；deleteLast删除最后一个，用于内存淘汰，调用deleteNode

~~~java
class LRUCache {
    class DLinkedList{
        int key,value;
        DLinkedList pre,next;
        public DLinkedList(){}
        public DLinkedList(int _key, int _value){
            key = _key;
            value = _value;
        }
    }
    
    private int capacity, size;
    private DLinkedList head, tail;
    private Map<Integer,DLinkedList> map = new HashMap<>();


    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        head = new DLinkedList();
        tail = new DLinkedList();
        head.next = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        DLinkedList node = map.get(key);
        if(node == null){
            return -1;
        }
            moveFirst(node);
            return node.value;
        
    }
    
    public void put(int key, int value) {
        DLinkedList node = map.get(key);
        if(node == null){
            DLinkedList newNode = new DLinkedList(key,value);
            map.put(key,newNode);
            addFirst(newNode);
            
            size++;
            if(size > capacity){
                DLinkedList temp = deleteLast();
                map.remove(temp.key);
                size--;
            }
        }else{
            node.value = value;
            moveFirst(node);
        }
    }

    private void addFirst(DLinkedList node){
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    }

    private void deleteNode(DLinkedList node){
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }

    private void moveFirst(DLinkedList node){
        deleteNode(node);
        addFirst(node);
    }

    private DLinkedList deleteLast(){
        DLinkedList last = tail.pre;
        deleteNode(last);
        return last;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
~~~



### 两数之和

leetcode 01

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。2 <= nums.length <= 103

~~~
示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
~~~

~~~java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            if(map.containsKey(target - nums[i]))
                return new int[]{map.get(target - nums[i]),i};
            map.put(nums[i], i);
        }
        return new int[0];
    }
}
~~~

思路：

- 第一时间想到用两个for循环枚举暴力解法。但是可以用空间换时间
- 在一次遍历中，用一个HashMap保存数组中各个元素，key为值，value为数组下标，添加过程中如发现哈希表中存在target-当前遍历值，返回其下标

### 两数相加！！！

leetcode 2

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，**并以相同形式返回一个表示和的链表**，返回一个新链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**表示342+465

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

~~~java
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
~~~

思路：

- 逆序排列数字是为了方便我们加，从头开始先加个位，短的后面高位补0就行了

- 链表开始一位对一位往后加，记住进位
- 短的链表后面补0
- 如果最后循环结束l1和l2都遍历完了进位仍为1，补一个结点1
- 用一个dummy结点方便返回头结点，cur结点往下构建新节点

~~~java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        //进位
        int carry = 0;

        while(l1 != null || l2 != null){
            int x = l1 == null ? 0 : l1.val;
            int y = l2 == null ? 0 : l2.val;
            
            int sum = x + y + carry;
            carry = sum/10;
            int res = sum % 10;

            cur.next = new ListNode(res);
            cur = cur.next;

            if(l1 != null) l1 = l1.next;
            if(l2 != null) l2 = l2.next;

        }
        if(carry == 1)
            cur.next = new ListNode(1);
        return dummy.next;
    }
}
~~~



### 三数之和！！！！！！

leetcode 15

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

~~~
示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：

输入：nums = []
输出：[]
示例 3：

输入：nums = [0]
输出：[]

~~~

思路：排序+双指针逼近

- 先将数组排序，固定一个值，然后用双指针去寻找这个固定值的负数 

- 注意在查找过程中注意去重，固定的值需要去重，双指针行进过程中也需要去重，这题的难点就在于去重
- 固定一个值，用for循环遍历数组，遍历的时候如果发现遍历到正数了那么必然加起来不可能为0直接退出循环，如果同时去重。分为三数加起来正好相等的话那么就加入结果集，如果小于那么左指针+1，如果大于那么右指针-1，同时做好左右指针的去重
- List<String> list = Arrays.asList("a","b","c");该方法将数组转化为List集合

~~~java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums.length < 3) return res;
        Arrays.sort(nums);

        for(int i = 0; i < nums.length - 2; i++){
            if(nums[i] > 0) break;
            if(i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1,right = nums.length - 1;
            int target = -nums[i];

            while(left < right){
                if(nums[left] + nums[right] == target){
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    left++;
                    right--;
                    while(left < right && nums[left] == nums[left - 1])
                        left++;
                    while(left < right && nums[right] == nums[right + 1])
                        right--;
                }else if(nums[left] + nums[right] < target){
                    left++;
                }else{
                    right--;
                }
            }
        }
        return res;
    }
}
~~~



### 无重复字符的最长子串（滑动窗口）！！！

leetcode 03 ,剑指offer 48

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

思路：双指针 i , j 加HashMap

- 右指针 j 遍历字符s，用一个HashMap记录每个字符最后一次出现的位置
- 更新左指针，保证 i + 1 和 j之间无重复的字符，所以i的初始值赋-1；如果map中已经出现过这个字母了那么就将这个i指针更新到之前出现的位置，那么i+1到j之间就不会有重复了
- 为防止出现abba,即a的索引在之前，导致回到了很久之前，但是中途已经出现其他重复的了，所以得用 i = Math.max(i,map.get(temp));，保证i不回退
- 那么最大值便是 j - i,在循环中不断更新这个最大值就行了

~~~ java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int i = -1, max = 0;
        HashMap<Character,Integer> map = new HashMap<>();
        for(int j = 0; j < s.length(); j++){
            char temp = s.charAt(j);
            if(map.containsKey(temp))
                //防止两个相同字符中间出现重复如abba,i不能开倒车
                i = Math.max(i,map.get(temp));
            map.put(temp,j);
            max = Math.max(max,j - i);
        }
        return max;
    }
}
~~~

### 买卖股票的最佳时机

leetcode 121 ,剑指offer 63

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 

~~~
示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

~~~

思路：动态规划

- dp[i]表示第以prices[i]结尾的最大利润
- **转移方程：dp[i] = max(dp[i-1],prices[i] - min(price[0:i]))前i-1日最大利润和第i日价格减去之前最低价格**
- 初始状态dp[0]=0，返回dp[n-1],n为dp数组长度
- 空间优化：由于dp[i]只与dp[i-1],prices[i]和min_price有关，可以用变量代替dp列表

~~~java
class Solution {
    public int maxProfit(int[] prices) {
        int min_price = Integer.MAX_VALUE;
        int profit = 0;

        for(int price : prices){
            min_price = Math.min(min_price,price);
            profit = Math.max(profit,price - min_price);
        }
        return profit;
    }
}
~~~

### 从前序和中序遍历构造二叉树*

leetcode 105 ,剑指offer 07

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

思路：

- 前序遍历第一个节点为根结点，然后在中序遍历中找到这个根结点，中序遍历根结点左边是左子树右边是右子树。然后分别对左右子树递归，构造二叉树。

- 细节，在中序遍历找根结点时，可以把中序遍历加入HashMap这样不用每次都要遍历数组找根结点。

~~~java
class Solution {
    private HashMap<Integer,Integer> map;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        map = new HashMap<>();
        for(int i = 0; i < inorder.length; i++){
            map.put(inorder[i],i);
        }
        return myBuildTree(preorder,inorder,0,preorder.length - 1,0,inorder.length -1);
        
    }

    public TreeNode myBuildTree(int[] preorder, int[] inorder,int pre_left,int pre_right,int in_left,int in_right){
        if(pre_left > pre_right) return null;
        int pre_root = pre_left;
        int in_root = map.get(preorder[pre_root]);

        TreeNode root = new TreeNode(preorder[pre_root]);
        int size = in_root - in_left;

        root.left = myBuildTree(preorder,inorder,pre_left + 1,pre_left + size,in_left,in_root - 1);
        root.right = myBuildTree(preorder,inorder,pre_left + 1 + size,pre_right,in_root + 1,in_right);

        return root;
    }
}
~~~

### 从中序遍历和后续遍历构造二叉树*

leetcode 106

思路：

- 注意，加上size正常是多算一个的，要减1，上一题因为前序遍历第一个为根，本来就是要多加一的，所以不减一
- 只要记住直接加size相对尾会多算一个，上一题前面多一个根结点就不用减

~~~java
class Solution {
    HashMap<Integer,Integer> map;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int n = inorder.length;
        map = new HashMap<>();
        for(int i = 0; i < n; i++){
            map.put(inorder[i],i);
        }
        return myBuildTree(inorder,postorder,0,n-1,0,n-1);
    }

    public TreeNode myBuildTree(int[] inorder, int[] postorder,int in_left,int in_right,int post_left,int post_right){
        if(in_left > in_right) return null;
        int post_root = post_right;
        int in_root = map.get(postorder[post_root]);
        TreeNode root = new TreeNode(postorder[post_root]);
        int size = in_root - in_left;

        root.left = myBuildTree(inorder,postorder,in_left,in_root - 1,post_left,post_left + size - 1);
        root.right = myBuildTree(inorder,postorder,in_root + 1,in_right,post_left + size,post_right - 1);

        return root;
    }
}
~~~







### 二叉树的层序遍历!!!

leetcode 102 剑指offer 32

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 思路：新建一个队列，将根结点加入队列，每取出一个结点将他的左右孩子加入队列，迭代

~~~java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        //不能漏
        if(root == null) return res;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while(!q.isEmpty()){
            int n = q.size();
            List<Integer> temp = new ArrayList<>();
            for(int i = 0; i < n; i++){
                TreeNode node = q.poll();
                temp.add(node.val);
                if(node.left != null) q.offer(node.left);
                if(node.right != null) q.offer(node.right);
            }
            res.add(temp);
        }
        return res;
    }
}
~~~

### 二叉树的右视图

leetcode 199

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

思路：对二叉树进行层序遍历，每层的最后一个就是右视图的成员

~~~java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
                if (i == size - 1) {  //将当前层的最后一个节点放入结果列表
                    res.add(node.val);
                }
            }
        }
        return res;
    }
}
~~~



### 二叉树之字形，锯齿状层序遍历

leetcode 102 剑指offer 32

~~~
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
~~~

思路：在102基础上，将ArrayList换成LinkedList，再加一个标志位用来判断是偶数层还是奇数层选用不同的打印顺序，偶数层直接在LinkedList后面加值，奇数层在LinkedList头结点加值。弄完一层以后把标志位反转。

~~~java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if(root == null) return res;
        Queue<TreeNode> nodeQueue = new LinkedList<>();
        nodeQueue.offer(root);
        //用一个标志位来判断是偶数层还是奇数层，从0开始偶数层从左到右打印，奇数层从右到左
        boolean isEvenLevel = true;
        while(!nodeQueue.isEmpty()){
            LinkedList<Integer> temp = new LinkedList<>();
            int size = nodeQueue.size();
            for(int i = 0; i < size; i++){
                TreeNode node = nodeQueue.poll();
                if(isEvenLevel){
                    temp.add(node.val);
                }else{
                    temp.addFirst(node.val);
                }

                if(node.left != null) nodeQueue.offer(node.left);
                if(node.right != null) nodeQueue.offer(node.right);
            }
            res.add(temp);
            isEvenLevel = ! isEvenLevel;
        }
        return res;
    }
}
~~~

### 二叉搜索树的公共祖先

**在二叉树中只要p和q在一个结点的左右子节点，那么这个结点就是最近公共祖先**

LeetCode 235 剑指offer68

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

最近公共祖先:对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。条件：所有节点的值都是唯一的。p,q都存在于此二叉树中。



思路：

- 前提条件为二叉搜索树，那么，比根结点小的都在左边，比根结点大的都在右边
- 如果p和q同时大于根，那么最近公共祖先一定在右边，root = r.right
- 如果p和q同时小于根，那么最近公共祖先一定在左边，root = r.left
- 如果不满足，即p和q在根左边和右边那么这个根就是最近公共祖先，如果p或q等于根结点了，那么也是最近公共祖先了

~~~java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while(root != null){
            if(root.val < p.val && root.val < q.val){
            root = root.right;
        }else if(root.val > p.val && root.val > q.val){
            root = root.left;
        }else{
            break;
        }
        
        }
        return root;
    }
}
~~~

### 二叉树的最近公共祖先*

LeetCode 236 剑指offer68

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。注意不是二叉搜素树了，是二叉树

思路：从底至顶回溯

~~~java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null;
        if(root == p || root == q) return root;

        //递归遍历左子树，找p和q，谁先找到返回谁
        TreeNode left  = lowestCommonAncestor(root.left,p,q);
        //递归遍历右子树，找p和q，谁先找到返回谁
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        //如果左子树p和q都找不到，p和q一定在右子树中，右子树先遍历到的那个就是公共祖先
        if(left == null) return right;
        //如果右子树p和q都找不到，p和q一定在左子树中，左子树先遍历到的那个就是公共祖先
        if(right == null) return left;

        //左右子树都不为空，那么这个结点就是公共结点
        return root;
    }
}
~~~



### 环形链表

leetcode 141

给定一个链表，判断链表中是否有环。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

思路：

- 一个快指针一次移动两步，一个慢指针一次移动一步，如果有环，他们一定会在环中相遇
- 注意因为fast一次走两步，所以if(fast == null || fast.next == null)，只要fast遍历过最后一个结点就说明链表中无环，这和每次走一步判断条件不一样，要注意

如果是同一起点

~~~java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null)
            return false;
        ListNode slow = head;
        ListNode fast = head;

        while(true){
            if(fast == null || fast.next == null)
                return false;
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast) break;
        }
        return true;
    }
}
~~~

### 环形链表2!!!

leetcode 142

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。O(1)解决。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

思路：双指针数学推导，需要记忆数学规律，第一次遇到基本做不出来

![image-20210413231148415](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210413231148415.png)

总结规律：快慢指针同时从head出发，第一次在环中相遇后，把快指针移到head然后一次走一步，再次相遇的结点就是链表入口

- 第一次相遇时慢指针已经走了nb步
- 走a+nb步一定是在环入口

~~~java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head,slow = head;
        while(true){
            if(fast == null || fast.next == null)
                return null;
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow) break;
        }

        fast = head;
        while(slow != fast){
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}
~~~

### 有效的括号*

leetcode 20

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

思路：

- for循环遍历字符串字符，每遇到左括号把它对应的右括号压入栈，遍历遇到右括号把它和弹栈出来的比较，如果不同提前返回false；
- 遍历字符过程中栈肯定不能空，如果是对称的那一定是遍历完最后一个字符正正好栈为空。中途为空说明右括号多了，结束后应该为空，不为空说明，左括号多了

~~~java
class Solution {
    public boolean isValid(String s) {
        if(s.isEmpty()) return true;
        Stack<Character> stk = new Stack<>();
        for(char c : s.toCharArray()){
            if(c == '('){
                stk.push(')');
            }else if(c == '{'){
                stk.push('}');
            }else if(c == '['){
                stk.push(']');
            //不为左括号说明是右括号,还没遍历完栈就为空说明右括号多了数量就不匹配
            }else if(stk.isEmpty() || c != stk.pop()){
                return false;
            }
        }
        //再判断防止左括号多了
        return stk.isEmpty();
    }
}
~~~



### 合并两个有序链表！！！

leetcode 21 ,剑指offer 25

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

思路：用两个指针（结点本身就是指针）遍历两个链表，比较两个指针指向结点大小，两节点交替前进，直至遍历完两个链表

小技巧：可以引入一个伪头结点，方便最后返回结果

​				用一个cur指针在两个链表之间游走，建立链表，另两个用于比较，所以总共用到了三个指针

- 这两题很像，都是用两个指针逐个比较，while循环必须保持两个指针都不为空，结束了在把还有的直接加入另一个
- l1和l2天然就是指针

~~~java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        //cur就是一个穿针引线的作用
        ListNode cur = dummy;

        while(l1 != null && l2 != null){
            if(l1.val <= l2.val){
                cur.next = l1;
                l1 = l1.next;
            }else{
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        cur.next = l1==null ? l2 : l1;
        return dummy.next;
    }
}
~~~

### 合并两个有序数组*

LeetCode 88

给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中*，*使 `nums1` 成为一个有序数组。

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

思路：

- 思路的重点一个是从后往前确定两组中该用哪个数字
- 结束条件以第二个数组全都插入进去为止

~~~java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1;
        int p2 = n - 1;
        int p = m + n - 1;

        while(p1 >= 0 && p2 >= 0){
            if(nums1[p1] > nums2[p2]){
                nums1[p--] = nums1[p1--];
            }else{
                nums1[p--] = nums2[p2--];
            }
        }
        //面的while循环有可能是从p1条件退出，此时p2还没遍历完，所以此时对应的情况是p1中最小的数比p2当前的数大，所以最后一句将p2中剩余的数一次性拷贝到nums1的头部.如果p1先结束，那本身就是在p1中不用动
        System.arraycopy(nums2,0,nums1,0,p2 + 1);
    }
}
~~~



### 链表中倒数第K个结点

剑指offer 22

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

思路：用双指针，不用统计链表长度。前指针先往后走k步，然后后指针和前指针一起往后走，当前指针为null时即后指针距离尾结点k-1,即倒数第k个

~~~java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        if(head == null || k == 0) return null;
        ListNode former = head;
        ListNode latter = head;

        for(int i = 0; i < k; i++){
            if( former == null) return null;
            former = former.next;
        }

        while(former != null){
            former = former.next;
            latter = latter.next;
        }
        return latter;
    }
}
~~~

### 两个栈实现队列**

剑指offer 09

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

~~~
示例 1：
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
~~~

思路：

- 一个队列具备的两个功能分别由两个栈来完成：栈A实现入队加入队尾功能，栈B实现出队删除队头功能
- 必须在一开始初始化两个栈，因为方法参数中无栈，为全局变量
- 只有在stack_out为空时才一次性把stack_in一次性全部装入stack_b;

~~~java
class CQueue {
    Stack<Integer> stack_in;
    Stack<Integer> stack_out;
    public CQueue() {
       
            stack_in = new Stack<>();
            stack_out = new Stack<>();
        
    }
    
    public void appendTail(int value) {
        stack_in.push(value);
    }
    
    public int deleteHead() {
        if(stack_out.isEmpty()){
            while(!stack_in.isEmpty()){
                stack_out.push(stack_in.pop());
            }
        }
        if(stack_out.isEmpty()){
             return -1;
        }else{
            int deleteItem = stack_out.pop();
            return deleteItem;
        }
           
      
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
~~~



### 斐波那契

剑指offer 10

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.

思路：	状态转移方程：f(n) = f(n-1) +f(n-2);

~~~java
class Solution{
    public int fib(int n){
        if(n == 0) return 0;
        if(n == 1) return 1;
        int first = 0，second = 1;
        int sum = 0;
        for(int i=2;i<=n;i++){
            sum = first + second;
            first = second;
            second = sum;
        }
        return sum;
    }
}
~~~



### 青蛙跳台阶/爬楼梯

LeetCode 70 剑指offer 10 

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。

思路：	

- 状态转移方程：f(n) = f(n-1) +f(n-2);

- 注意跳台阶当台阶数为0或1，跳法都是1.青蛙跳台阶和斐波那契就是初始值不一样其他都是一样的。
- **动态规划听上去高大上，其实就是用空间换时间而已，将过去的计算状态保存下来，自底向上用for循环往上推**

~~~java
class Solution {
    public int climbStairs(int n) {
        if(n == 0 || n == 1) return 1;
        int first = 1, second = 1;
        int sum = 0;
        for(int i = 2; i <= n; i++){
            sum = first + second;
            first = second;
            second = sum;
        }
        return sum;
    }
}
~~~

### 凑零钱、零钱兑换！！！

LeetCode 322

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

**示例 1：**

~~~java
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
~~~

思路：动态规划

- dp[i]表示，当目标金额amount为i时至少要dp[i]枚硬币凑出
- **Arrays.fill（）**方法，用于一维数组、二维数组的初始化或者填充，如果有两个参数，第一个参数为数组，第二个参数为要往里面加的每个值
- 初始值0元钱要0个硬币
- 状态转移方程：dp[i] = 所有面值里1+dp[i - coin]最小的
- **为什么一开始要初始化所有dp数组为amount + 1？**因为一个amount值最多由amount个硬币组成，一开始初始化为amount+1那么就**相当于初始化为正无穷，方便min操作**；如果这个硬币凑不出来那么最小值还是amount+1，返回-1
- 比如目标值为4，硬币面值为3，那么dp[4]就不存在
- if(coin > i) continue;一定要加因为后面要算dp[i-coin]

~~~
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp,amount + 1);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            for(int coin : coins){
                if(coin > i) continue;
                dp[i] = Math.min(dp[i],1 + dp[i - coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }
}
~~~

### 最长回文子串

LeetCode 5

给你一个字符串 `s`，找到 `s` 中最长的回文子串。1 <= s.length <= 1000,s仅由数字和英文字母组成。简单说就是两个相同字符所占的最大长度

**示例 1：**

~~~java
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
~~~

~~~java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    public int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            --left;
            ++right;
        }
        return right - left - 1;
    }
}
~~~



### 相交链表、两个链表的第一个公共结点！！！

LeetCode 160  剑指offer52

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。



思路：两个指针分别指向链表头结点，往后遍历，当一个一个指针为null，给他换到另一个链表的头结点，继续往下遍历，这样下去两个指针走的路程一定会相同，相遇的就为第一个公共结点。时间复杂度O（M+N），空间复杂度O（1）



~~~java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode PA = headA;
        ListNode PB = headB;
        while (PA != PB) {
            PA = PA == null ? headB : PA.next;
            PB = PB == null ? headA : PB.next;
        }
        return PA;
    }
}
~~~

### 字符串相加

LeetCode 415

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和。**你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式**，所以返回也是返回String

思路：模拟人工的加法

- 真正计算的话，char字符是可以直接计算的，字符  -  ‘0’就是数字的值

- 加法都是又对齐开始，从最后一位开始，依次往前，记录上一位加下一位，再记录下进位
- 如果一个字符串遍历完了，就让他的值为0
- 注意最后要反转一下

~~~java
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder res = new StringBuilder();
        int i = num1.length() - 1, j = num2.length() - 1;
        int add = 0;

        while(i >= 0 || j >= 0 || add == 1){
            int x = i >= 0 ? num1.charAt(i) - '0' : 0;
            int y = j >= 0 ? num2.charAt(j) - '0' : 0;
            int temp = x + y + add;
            add = temp / 10;
            res.append(temp % 10);
            i--;
            j--;
        }
        return res.reverse().toString();
    }
}
~~~

### x的平方根***

LeetCode 69

实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 2:**

```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```

思路：

- 二分查找，找右边界

~~~java
class Solution {
    public int mySqrt(int x) {
        long left = 0;
        long right = x;

        while(left <= right){
            long mid = left + (right - left) / 2;
            if(mid * mid > x){
                right = mid - 1;
            }else if(mid * mid <= x){
                left = left + 1;
            }
        }
        return (int)right;
    }
}
~~~

### 最大子序和*

LeetCode 53 剑指offer 42

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

思路：动态规划

- 以f(i)表示以第i个数结尾的最大子序和，f(i)的值可以表示为nums[i] 和f(i-1) + nums[i] 之间的最大值，这个角度就是nums[i]不变，看看f(i-1)对最后结果的影响是正的还是负的，最后的nums[i]一定要有

~~~java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0;
        int res = nums[0];

        for(int num : nums){
            pre = Math.max(num + pre,num);
            res = Math.max(res,pre);
        }
        return res;
    }
}
~~~



### 螺旋矩阵、顺时针打印矩阵

LeetCode 54 剑指offer 29

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

思路：

- 设立上下左右四条边界
- 从左往右、从上往下、从右往左、从下往上打印
- 注意像if(++top>bottom) break;是这题灵魂，比如从左往右，这句话既判断是否打印完，又给top+了1，防止重复算上边界四个角的值.

~~~java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
         List<Integer> res = new ArrayList<>();
         if(matrix.length == 0) return res;

        int left = 0,right = matrix[0].length - 1,top = 0,bottom = matrix.length - 1;

        while(true){
            for(int i=left;i<=right;i++)  res.add(matrix[top][i]);
            if(++top>bottom) break; 

            for(int i=top;i<=bottom;i++)  res.add(matrix[i][right]);
            if(--right<left) break; 

            for(int i=right;i>=left;i--)  res.add(matrix[bottom][i]);
            if(--bottom<top) break;

             for(int i=bottom;i>=top;i--) res.add(matrix[i][left]);
            if(++left>right) break;
        }
        return res;
    }
}
~~~

### 对称的二叉树

LeetCode 101 剑指offer 28

~~~java
请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3

示例 1：

输入：root = [1,2,2,3,4,4,3]
输出：true
~~~

思路：将一棵树与它的镜像相比，然后递归

~~~java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return recur(root,root);
    }

    public boolean recur(TreeNode node1,TreeNode node2){
        if(node1 == null && node2 == null) return true;
        if(node1 == null || node2 == null ||node1.val != node2.val) return false;
        return recur(node1.left,node2.right) && recur(node1.right,node2.left);
    }
}
~~~

### 在排序数组中查找元素第一个和最后一个位置

LeetCode 34 剑指offer 53

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

**示例 1：**

~~~java
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
~~~



二分查找技巧：

- 查找右边界，left = mid + 1,返回right，检查if(right < 0 || nums[right != target])
- 查找左边界，right = mid - 1,返回left,检查if(left >= nums.length || nums[left]!=tag=rget)

~~~
class Solution {
    public int[] searchRange(int[] nums, int target) {
       int start = find(nums,target);
       int end = find(nums, target+1) - 1;
       if(start>=nums.length||nums[start]!=target)
            return new int[]{-1,-1};
        return new int[]{start,end};
    }

    public int find(int[] nums, int target){
        int left = 0;
        int right = nums.length - 1;

        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] < target){
                left = mid + 1;
            }else if(nums[mid] >= target){
                right = mid - 1;
            }
        }
        return left;
    }
}
~~~



### 排序链表

LeetCode 148

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

- 你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

### 二叉搜索树原地转换成排序的循环双向链表

LeetCode 426，剑指offer 36

为了让您更好地理解问题，以下面的二叉搜索树为例：

 

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png)

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

思路：对二叉搜索树进行中序遍历，中序遍历的同时构建cur和前驱结点pre的引用指向。中序遍历完成后构建头结点和尾结点的引用指向。

~~~java
class Solution {
    Node pre,head;
    public Node treeToDoublyList(Node root) {
        if(root == null) return null;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }

    public void dfs(Node cur){
        if(cur == null) return;
        dfs(cur.left);
        cur.left = pre;
        if(pre == null) head = cur;
        else pre.right = cur;
        pre = cur;
        dfs(cur.right);
    }
}
~~~

### 验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

思路：

- 中序遍历，现在的结点值肯定比之前的大
- 注意第一次初始化pre前一个值为了通过测试用例设置为Double.MAX_VALUE;
- 注意判断的时候，等于也不行

~~~java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Deque<TreeNode> stack = new LinkedList<>();
        double pre = -Double.MAX_VALUE;
        while(root != null || !stack.isEmpty()){
            while(root!= null){
                stack.push(root);
                root = root.left;
            }

            root = stack.pop();
 			//注意等于也不行
            if(root.val <= pre) return false;
            pre = root.val;
            root = root.right;
        }
        return true;
    }
}
~~~

### 验证平衡二叉树

LeetCode 110 剑指offer 55

给定一个二叉树，判断它是不是平衡的二叉树。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

思路：后序遍历+剪枝

- 递归，如果当前结点左右子树高度差小于2则返回当前深度，如果大于等于二说明不是平衡二叉树，返回-1
- 后序遍历过程中可以提前剪枝，如果已经等于-1了说明不是平衡二叉树直接返回-1
- 注意：树深度 = 左右子树最大深度+1

~~~java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return recur(root) != -1;
    }
    
    public int recur(TreeNode root){
        if(root == null) return 0;
        int left = recur(root.left);
        if(left == -1) return -1;
        int right = recur(root.right);
        if(right == -1) return -1;
        return Math.abs(left - right) < 2 ? Math.max(left,right) + 1 : -1;
    }
}
~~~

### 链表中倒数第k个结点!!!

 剑指offer 22

​	输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

​	例如，一个链表有 `6` 个节点，从头节点开始，它们的值依次是 `1、2、3、4、5、6`。这个链表的倒数第 `3` 个节点是值为 `4` 的节点。

**例：**

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

思路：

- 双指针从头结点出发，cur先走k步，然后一起走
- cur走到空，那么pre正好是第k个，边界就是这样正好不用考虑+1-1
- if(cur == null) return null;一定要放在循环里面，因为**只有一个的话会出错会返回null，细节是魔鬼**
- 在里面为空说明超了，在外面为空在只有一个元素的情况下，一次就为null了

![image-20210406203107489](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210406203107489.png)

~~~java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        if(head == null || k < 1) return null;
        ListNode pre = head;
        ListNode cur = head;

        for(int i = 0; i < k; i++){
            //防止k过长
            if(cur == null) return null;
            cur = cur.next;
        }

        while(cur != null){
            pre = pre.next;
            cur = cur.next;
        }
        return pre;
     }
}
~~~

### 二叉树的最大深度

LeetCode 104 剑指offer 55

思路

- 二叉树最大深度 = 1 + Math.max(左子树深度，又子树深度)；

递归dfs解法

~~~java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return 1 + Math.max(left,right);
    }
}
~~~

### 全排列！！！

LeetCode 46

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

~~~java
示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
~~~

思路：回溯

- track用来记录已选择组成的路劲
- 每track的长度等于数组长度，就加入结果
- 注意递归一定要有结束条件返回
- 巧妙利用 if(track.contains(nums[i])) continue;排除已经选择过的

~~~java
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> permute(int[] nums) {
        res = new LinkedList<>();
        LinkedList<Integer> track = new LinkedList<>();
        backtrack(nums,track);
        return res;

    }

    public void backtrack(int[] nums,LinkedList<Integer> track){
        if(track.size() == nums.length){
            res.add(new LinkedList(track));
            return;
        }

        for(int i = 0; i < nums.length; i++){
            if(track.contains(nums[i])) continue;

            track.add(nums[i]);
            backtrack(nums,track);
            track.removeLast();
        }
    }
}
~~~

### 搜索旋转排序数组

LeetCode 33

​	整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。然后对其旋转，给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的索引，否则返回 `-1` 。

思路：

- 什么是旋转数组，例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。
- 也就是说一个升序数组被分成了两个升序数组，取一个mid值，分割成两个数组[l, mid]` 和 `[mid + 1, r]，**其中必定有一个是有序的**,分割出来必定是一个有序一个无序。
- 如果[l, mid - 1]是有序的，l <= target <= mid ，就将搜索范围缩小至[l, mid - 1]
- 如果[mid + 1, r]是有序的，mid + 1 <= target <= r ，就将搜索范围缩小至[mid + 1, r]
- 只对有序的进行查找，不断循环对有序的二分看看target在不在里面，有序就可以判断target在不在范围里，不在这个范围里就去另一边找，再循环，再分。

~~~java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target){
                return mid;
            }

            if(nums[mid] >= nums[left]){
                if(nums[left] <= target && target < nums[mid]){
                    right = mid - 1;
                }else{
                    left = mid + 1;
                }
            }else{
                if(nums[mid] < target && target <= nums[right]){
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}
~~~

### 旋转数组的最小数字

剑指offer 11 LeetCode 153

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。

**示例 1：**

输入：[3,4,5,1,2]
输出：1

思路：

- 核心思想：每次二分取一个mid值，这个mid值的左边或者右边肯定有一部分是有序的，mid值肯定不在那个有序的半边，通过每次和最右边的值比较可以判断现在支点左边是有序还是右边有序。有一种特殊情况就是pivot和最右边的值相等，这种情况让right--就好。

- mid值小于最右边值，说明右边是有序的，右边肯定没有最小值，mid可能是最小值，所以 right = mid
- mid值大于右边值，说明左边有序，最小值在右边，mid必然不是最小值，因为它已经大于右边的了，所以

left = mid + 1

- 如果mid值和最右边的值相等，可以把right--,反正right都是有替代品

~~~java
class Solution {
    public int minArray(int[] numbers) {
        int left = 0;
        int right = numbers.length - 1;

        while(left <= right){
            int mid = left + (right - left) / 2;
            if(numbers[mid] > numbers[right]){
                left = mid + 1;
            }else if(numbers[mid] < numbers[right]){
                right = mid;
            }else{
                right--;
            }
        }
        return numbers[left];
    }
}
~~~



### 数组中重复的数字

剑指offer 03

找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。不知道有几个数字重复，也不知道每个数字重复了几次。找出任意一个重复的数字。2 <= n <= 100000

**示例 1：**

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

思路：

- 数组长度为n，所有数字又都在0到n-1的范围内，那么如果数组中没有重复数字的话，一定是下标和数值相等，也就是nums[i] = i
- 那么如果数组中有重复数字，必定不符合一个萝卜一个坑。
- 将数组中元素从下标0开始移动到它对应下标位置，即nums[i]移动到nums[nums[i]]
- 不断移动，如果数组中有重复的，交换过程一定会发现要交换的和现在的相等，交换后还是一样

~~~java
class Solution {
    public int findRepeatNumber(int[] nums) {
        for(int i = 0;i<nums.length;i++){
            //只有不符合当前值等于下标才要交换，外面还要套一层while或if
            while(nums[i] != i){
                if(nums[i] == nums[nums[i]]){
                    return nums[i];
                }

                int temp = nums[i];
                nums[i] = nums[temp];
                nums[temp] = temp;
            }
        }
       return -1;
    }
}
~~~

### 二维数组中查找值

LeetCode 240 剑指offer 04

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

判断数组中是否存在这个数。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

思路：

- 从左下角和右上角来看，往两边要么减要么增，有点类似于二叉搜索树，所以可以从左下角或者右上角出发
- 比如从左下角出发，大于目标值行-1，小于目标值列+1

~~~java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int i = matrix.length - 1;
        int j = 0;

        while(i >= 0 && j < matrix[0].length){
            if(matrix[i][j] > target){
                i--;
            }else if(matrix[i][j] < target){
                j++;
            }else{
                return true;
            }
        }
        return false;
    }
}
~~~

### 从尾到头打印链表

剑指offer06

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

**示例 1：**

```
输入：head = [1,3,2]
输出：[2,3,1]
```

思路：

- 把链表加入栈，然后依次pop()出来打印

~~~java
class Solution {
    public int[] reversePrint(ListNode head) {
        Deque<ListNode> stack = new LinkedList<>();
        
        while(head != null){
            stack.push(head);
            head = head.next;
        }

        int n = stack.size();
        int[] res = new int[n];

        for(int i = 0; i < n; i++){
            res[i] = stack.pop().val;
        }
        return res;
    }
}
~~~

### 数组中超过一半的数字

LeetCode 169 剑指offer 39

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1:**

```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```

思路：

- 投票法
- 设众数票数+1非众数票数减一，那么数组所有数的和一定大于0
- 若数组前a个数票数和为0，那么剩下的n-a票数肯定也是大于0的，即后n-1个数的众数也是一样的，这样每当票数为0都可以缩小数组的搜索范围
- 从头到尾遍历，先以第一个数作为众数，后续遇到相同值票数加一遇到不同值票数减一，如果发现票数为0了，缩小数组范围，把前面的去掉，以现在遍历的值作为众数，再次遍历。能始终使得众数票数大于0的那就是最终结果了

~~~java
class Solution {
    public int majorityElement(int[] nums) {
        int votes = 0;
        int res = 0;
        for(int num : nums){
            if(votes == 0) res = num;
            if(num == res) votes++;
            else votes--;
        }
        return res;
    }
}
~~~

### 矩阵中的路径、二维数组搜索单词是否存在！！！

LeetCode 79 剑指offer 12

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

~~~
示例:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
~~~

思路：

- 遍历二维数组中的每一个字符，以这个字符为起点dfs下去看看有没有符合的，有则返回true,没则返回false;
- dfs辅助函数表示以board[i] [j]为起点开始往下搜索，注意这个k表示当前遍历到了字符数组第几个结点，如果遍历完了k = length - 1了，那说明存在返回true,如果起点不等于或者索引越界返回false;

~~~java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i = 0; i < board.length; i++){
            for(int j = 0; j < board[0].length; j++){
                if(dfs(board,words,i,j,0)){
                    return true;
                }
            }
        }
        return false;
    }

    //dfs的功能是，在二维数组以board[i][j]为起点是否有符合的结果，k表示目前遍历到了字符数组中的哪一个，如果k=words.length - 1了那说明遍历完了
    public boolean dfs(char[][] board, char[] words, int i, int j, int k){
        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != words[k])
            return false;
        
        if(k == words.length - 1) return true;

        board[i][j] = '\0';
        boolean res = dfs(board,words,i-1,j,k+1) || dfs(board,words,i+1,j,k+1) || dfs(board,words,i,j+1,k+1) || dfs(board,words,i,j-1,k+1);
        board[i][j] = words[k];
        return res;
    }
}
~~~

### 机器人的运动范围

剑指offer 13

​	地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

**示例 1：**

```
输入：m = 2, n = 3, k = 1
输出：3
```

**提示：**

- `1 <= n,m <= 100`
- `0 <= k <= 20`

思路：

- 题目要求横坐标和纵坐标的数位之和不能超过k，先封装一个函数，用来计算一个数的数位和
- 计算一个数的数位和可以对10求余，得到的就是各位，然后再除10删除最后一位
- 可以回溯加剪枝，和12题有些类似，在递归中结束条件即为剪枝条件，用一个数组记录一个位置是否已经被访问过，区别在于12题是找路径，可能要回去开辟新路，而这题是找个数，访问过就是访问过了，不需要再回去了，所以递归后不需要修复原值

~~~java
class Solution {
    public int movingCount(int m, int n, int k) {
        boolean[][] visited = new boolean[m][n];
        return dfs(visited,m,n,k,0,0);
    }

    public int dfs(boolean[][] visited, int m, int n, int k, int i, int j){
        if(i >= m || j >= n || visited[i][j] || bitsum(i) + bitsum(j) > k) return 0;
        visited[i][j] = true;
        return 1 + dfs(visited,m,n,k,i+1,j) + dfs(visited,m,n,k,i,j+1);
    }

    public int bitsum(int n){
        int sum = 0;
        while(n != 0){
            sum += n % 10;
            n = n / 10;
        }
        return sum;
    }
}
~~~



### 最小栈

LeetCode 155

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

- push(x) —— 将元素 x 推入栈中。
- pop() —— 删除栈顶的元素，不返回值
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。

思路：

- 用两个栈，一个栈负责加入删除元素，一个栈负责保存目前的最小值，最小值始终在栈的最上面
- 加入值时，要和保存最小值的栈顶比较大小，如果小于等于栈顶则加入
- 删除值时，如果和保存最小值的栈相等则则将最小栈的元素也一并删除
- 注意包装类要使用equals比较大小，Integer会缓存-128到127的值，在这个范围内的值用==是true，出了这个范围是false

~~~java
class MinStack {

    /** initialize your data structure here. */
    private Deque<Integer> stack;
    private Deque<Integer> min_stack;
    public MinStack() {
        stack = new LinkedList<>();
        min_stack = new LinkedList<>();
    }
    
    public void push(int val) {
        stack.push(val);
        if(min_stack.isEmpty() || val <= min_stack.peek())
            min_stack.push(val);
    }
    
    public void pop() {
        if(stack.pop().equals(min_stack.peek()))
            min_stack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return min_stack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
~~~

### 二进制中位1的个数

剑指offer15 leetcode191

请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

~~~java
示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
~~~

法一：

- 输入的是一个32位得2进制整数，只要将这个数与1进行与运算，如果得0说明最后一位是0，如果为1说明最后一位是1
- 每判断一次最后一位就将这个二进制数进行一个无符号右移的操作，即高位补0，然后再重新判断最后一位，其中统计1出现的次数
- 注意n >>= 1;会超时，涉及 Java 中的 `算术右移` 和 `逻辑右移` 。算术右移>>，舍弃最低位，高位用符号位来填补。逻辑右移也就是无符号右移>>>，舍弃最低位高位用0填补。对于负数而言最高位为1，算术右移最高位仍然填1，也就是n永远不会为0，会死循环。

~~~java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0;
        while(n != 0){
            res += n & 1;
            n >>>= 1;
        }
        return res;
    }
}
~~~

法二：

- 法二更巧妙，利用了二进制中位运算的一个规律
- **n&(n-1)可以把n中出现的最后一个1变为0**

~~~java
public class Solution {
    public int hammingWeight(int n) {
        int res = 0;
        while (n != 0) {
            res += 1;
            n &= n - 1;
        }
        return res;
    }
}
~~~



### 数值的整数次方!!!

剑指offer16 leetcode50

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数（即，x^n）。不得使用库函数，同时不需要考虑大数问题。-2^31 <= n <= 2^31 -1

~~~java
示例 1：

输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：

输入：x = 2.10000, n = 3
输出：9.26100
~~~

思路：

- 最简单的方式就是一个for循环打印x个数,但是这种暴力解超时时间复杂度O(n)
- 可以用**快速幂**，将时间复杂度降到O(logn)
- 所谓快速幂就是将原本x^n，中的n用二进制表示，然后将二进制转化为10进制，转化为10进制时会出现很多2次幂，每后一个二次幂是前一个二次幂的平方，这样每次只需计算二次幂的平方即可，不用一个一个去计算，将时间复杂度降到了logn
- 注意因为有负数次幂，所以要将x变成1/x,次方变成正的，所以如果要用**int n**涉及到一个**-n**操作,那么-2^31变成2^31就超出int范围了，所以要用一个long变量存储n的值
- 注意==的优先级高于&，所以&要加括号
- ![image-20210419225231465](C:/Users/ql/AppData/Roaming/Typora/typora-user-images/image-20210419225231465.png)

~~~java
class Solution {
    public double myPow(double x, int n) {
        if(x == 0) return 0;
        long b = n;
        double res = 1.0;
        if(b < 0){
            x = 1 / x;
            b = -b;
        }
        while(b != 0){
            if((b & 1) == 1) res *= x;
            x *= x;
            b >>= 1;
        }
        return res;
    }
}
~~~

### 剪绳子、整数拆分求最大乘积

剑指offer14  LeetCode343

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。**说明:** 你可以假设 *n* 不小于 2 且不大于 58

**示例 1:**

~~~java
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
~~~

**示例 2:**

~~~java
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
~~~

法一：动态规划

思路：

- 用一个dp数组记录数i的拆分后最大乘积
- 那么可以写出状态转移方程，dp[i] = max(j * (i - j) , j * dp[i - j])，即拆出一个数字之后可以对另一部分继续拆即dp[i-j],也可以对另一部分不拆直接求乘积
- 初始状态是dp[2] = 1
- 第一层for循环表示第i个数字，第二个for循环表示每次切的数字，注意可以直接从2开始切，因为切出两个1对于乘积没有任何作用
- dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j])); 不同的j都会有一个dp[i]，这是在取不同的j情况下dp[i]的最大值

~~~java
class Solution {
    public int cuttingRope(int n) {
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for(int i = 3; i < n + 1; i++){
            for(int j = 2; j < i; j++){
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
}
~~~

法二：贪心，偏数学了

思路：数学结论

- 当所有绳段长度相等时乘积最大
- 最优绳的长度为3，尽量拆3
- double pow(double x, double y);
- 注意Math.pow返回double,需要用int强转
- int a = n / 3;用来看有几个3
- int b = n % 3;用来看余数，然后再决定如何处理多下来的数

~~~java
class Solution {
    public int integerBreak(int n) {
        if(n <= 3) return n-1;
        int a = n / 3;
        int b = n % 3;
        if(b == 0) return (int)Math.pow(3, a);
        //多一个1，1*3 < 2*2
        if(b == 1) return (int)Math.pow(3,a-1)*4;
        //多一个2，2就这样了拆成1*1反而更少
        if(b == 2) return (int)Math.pow(3,a)*2;
        return -1;
    }
}
~~~

### 删除链表结点

剑指offer 18

​	给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。

~~~java
示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
~~~

思路：

- 用两个指针，一个pre = head,一个cur = head.next,设置一个pre前驱指针只是为了删除节点方便可以直接指定pre.next = cur.next
- 第一个head值就为val为特殊情况，可以另外判断一下，比较总体上都是比较cur节点的值
- 要考虑链表中没有val这一情况，需要加入判断cur不为空

~~~java
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if(head.val == val) return head.next;
        ListNode pre = head;
        ListNode cur = head.next;

        while(cur != null && cur.val != val){
            pre = cur;
            cur = cur.next;
        }

        if(cur != null) pre.next = cur.next;
        return head;
    }
}
~~~

### 正则表达式匹配!!!!!!!!!!!!!!!!!!!!!

​	请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'**'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

~~~
示例 2:

输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
~~~

思路：

- . 匹配任意一个字符，*前面的字符可以出现任意次，包括0次
- 动态规划，由后往前推，写出状态转移方程，主要看最后一个字符是普通字符或者.还是*
- dp数组表示以i结尾的字符是否匹配
- 状态转移方程
  - 最后一位是正常字符或者是一个点匹配**dp[i] [j] = dp[i-1] [j - 1];**
  - 最后一位如果是星号。可以分为星号前面的字符出现0次和星号前面的字符出现了一次或者以上
  - 出现0次：**dp[i] [j] = dp[i] [j-2]**
  - 出现1次：**dp[i] [j] = dp[i-1] [j];**
- 主要大类分为正则为空和正则不为空两类

### 调整数组顺序使奇数位于偶数前面！！！

剑指offer21

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

~~~java
示例：

输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
~~~

思路：

- 左右两个指针，左指针从左往右搜索偶数，右指针从右往左搜素奇数，然后互换，只要左指针和右指针不相等就一直循环下去
- 因为是到左右指针相等所以用《
- 注意和快排不一样的要判断

~~~java
class Solution {
    public int[] exchange(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while(left < right){
            while(left < right && nums[left] % 2 == 1){
                left++;
            }

            while(left < right && nums[right] % 2 == 0){
                right--;
            }

            if(left < right){
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
            }
        }
        return nums;
    }
}
~~~

### 二叉树的镜像！！！！！！

剑指offer 27 LeetCode 226

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

​     4

   /   \
  2     7
 / \   / \
1   3 6   9
镜像输出：

​     4

   /   \
  7     2
 / \   / \
9   6 3   1

 

思路

- 递归就是自底向上交换左右
- 用队列就是自顶向下，

递归解法：

~~~java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if( root == null) return null;

        TreeNode leftRoot = mirrorTree(root.left);
        TreeNode rightRoot = mirrorTree(root.right);
        root.left = rightRoot;
        root.right = leftRoot;
        return root;
    }
}
~~~

非递归解法：

~~~java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return null;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            if(node.left != null) queue.offer(node.left);
            if(node.right != null) queue.offer(node.right);
            
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp;
        }
        return root;
    }
}
~~~

### 树的子结构

剑指offer 26

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构),B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

​		3
​	  / \

   4   5
  / \
 1   2
给定的树 B：

   4 
  /
 1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。



思路：

- recur函数负责判断**从当前节点开始**往下依次看是否符合相同结构
- 当B被遍历完那么说明有此子结构
- isSubStructure负责判断这个节点不行判断下一个左右节点，再来一次递归，通过或运算来实现，这个函数是把节点A和B传给recur的所以必不能为空，题目说了空树不是任意一个树的子结构，那么无论A或者B都不能为空
- recur中B遍历完了说明在A中找到了B，如果A都遍历完了或者这个A节点值不等了那么就说明以这个节点开始不存在

~~~java
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        return (A != null && B != null) && (recur(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B));
    }

    public boolean recur(TreeNode A, TreeNode B){
        if(B == null) return true;
        if(A == null || A.val != B.val) return false;

        return recur(A.left,B.left) && recur(A.right,B.right);
    }
}
~~~

