---
layout:     post
title:      重点算法题记录
subtitle:   概述
date:       2021-02-20
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 算法
---

# 重点算法题记录

**不能一次性流畅写对=面试写不出来=没做过！**

###  快速排序*

~~~java
public static void quickSort(int[] arrs, int L, int R){
    int i = L;
    int j = R;
    int pivot = arrs[(L + R) / 2];
    
    while(i <= j){
        while(pivot > arrs[i]){
            i++;
        }
        
        while(pivot < arrs[j]){
            j--;
        }
        
        if(i <= j){
            int temp = arrs[i];
            arrs[i] = arrs[j];
            arrs[j] = temp;
            i++;
            j--;
        }
        
        if(L <= j)
            quickSort(arrs, L, j);
        if(i <= R)
            quickSort(arrs, i, R);
        
    }
}
~~~



### 反转链表

剑指offer 24 leetcode 206

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

思路：用两个指针迭代，遍历链表，遍历的时候偶反转两个节点

~~~java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null,cur = head;
        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
~~~

### 数组中的第k个最大元素

leetcode 215

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。即排序后从后往前第k个，相当于索引nums.length - k

思路：大顶堆，删除堆顶k-1次，最后的堆顶就是我们要的结果

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

~~~java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeapify(nums,heapSize);
        for(int i = nums.length - 1; i >= nums.length - k + 1; i--){
            swap(nums, 0 , i);
            heapSize--;
            //交换完了堆顺序就不对了，以0为根根正一次
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }
	//从左到右，从上到下，用maxHeapify建堆
    public void buildMaxHeapify(int[] nums, int heapSize){
        //第一个非叶子结点是nums.length / 2 - 1
        for(int i = nums.length / 2 - 1; i >= 0; i--){
            maxHeapify(nums, i, heapSize);
        }
    }
	//这个函数作用是假定左右子节点已经是堆了
    public void maxHeapify(int[] nums, int curRoot, int heapSize){
        int l = curRoot * 2 + 1, r = curRoot * 2 + 2;
        int max = curRoot;
        if(l < heapSize && nums[l] > nums[max])
            max = l;

        if(r < heapSize && nums[r] > nums[max])
            max = r;

        if(max != curRoot){
            swap(nums,max,curRoot);
            maxHeapify(nums, max, heapSize);
        }
        
    } 
    //交换数组中对应值
    public void swap(int[] nums, int i , int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
~~~

### 每k个翻转链表

leetcode 25

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

~~~java
示例：

给你这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5
~~~



思路：

- 每次翻转前，要确定翻转链表的范围，这个必须通过 `k` 此循环来确定
- 需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来
- 初始需要两个变量 `pre` 和 `end`，`pre` 代表待翻转链表的前驱，`end` 代表待翻转链表的末尾
- 经过k此循环，`end` 到达末尾，记录待翻转链表的后继 `next = end.next`
- 翻转链表，然后将三部分链表连接起来，然后重置 `pre` 和 `end` 指针，然后进入下一次循环
- 特殊情况，当翻转部分长度不足 `k` 时，在定位 `end` 完成后，`end==null`，已经到达末尾，说明题目已完成，直接返回即可

~~~java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        //pre指向待翻转头结点前一个，end指向待翻转最后一个
        ListNode pre = dummy;
        ListNode end = dummy;
        //end指向每次要翻转的末尾
        while(end.next != null){
            for(int i = 0;i < k && end != null; i++) end = end.next;
            if(end == null) break;
            ListNode start = pre.next;
            ListNode next = end.next;
            //别忘了断开连接再反转链表
            end.next = null;
            pre.next = reverse(start);
            start.next = next;
            pre = start;
            end =start;
        }
        return dummy.next;
    }

    //反转链表
    public ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode cur = head;

        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
~~~

### LRU

leetcode 146

实现 LRUCache 类：

LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。



### 两数之和

leetcode 01

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。2 <= nums.length <= 103

~~~
示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
~~~

~~~java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            if(map.containsKey(target - nums[i]))
                return new int[]{map.get(target - nums[i]),i};
            map.put(nums[i], i);
        }
        return new int[0];
    }
}
~~~

思路：用一个HashMap保存数组中各个元素，一个个往里添加，添加过程中如发现哈希表中存在target-当前遍历值，返回其下标

### 三数之和

leetcode 15

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

~~~
示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：

输入：nums = []
输出：[]
示例 3：

输入：nums = [0]
输出：[]

~~~

思路：排序+双指针逼近

先将数组排序，固定一个值，然后用双指针去寻找这个固定值的负数

注意在查找过程中注意去重，固定的值需要去重，双指针行进过程中也需要去重

~~~java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums == null || nums.length < 3) return res;

        Arrays.sort(nums);
        for(int i = 0; i < nums.length - 2; i++){
            if(nums[i] > 0) break;
            //对i去重，i=0不会去重，i从1开始考虑去重
            if(i > 0 && nums[i] == nums[i - 1]) continue;

            int target = - nums[i];
            int left = i + 1, right = nums.length -1;
            while(left < right){
                if(nums[left] + nums[right] == target){
                    res.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));
                    left++;
                    right--;
                    //对左右指针去重
                    while(left < right && nums[left] == nums[left - 1])
                        left++;
                    while(left < right && nums[right] == nums[right + 1])
                        right--;
                }else if(nums[left] + nums[right] < target){
                    left++;
                }else{
                    right--;
                }
            }
            
        }
        return res;
    }
}
~~~



### 无重复字符的最长子串（滑动窗口）

leetcode 03 ,剑指offer 48

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

思路：双指针 i , j 加HashMap

- 右指针 j 遍历字符s，用一个HashMap记录每个字符最后一次出现的位置
- 更新左指针，保证 i + 1 和 j之间无重复的字符
- 那么最大值便是 j - i,在循环中不断更新这个最大值就行了

~~~ java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int i = -1, max = 0;
        HashMap<Character,Integer> map = new HashMap<>();
        for(int j = 0; j < s.length(); j++){
            char temp = s.charAt(j);
            if(map.containsKey(temp))
                //防止两个相同字符中间出现重复如abba,i不能开倒车
                i = Math.max(i,map.get(temp));
            map.put(temp,j);
            max = Math.max(max,j - i);
        }
        return max;
    }
}
~~~

### 买卖股票的最佳时机

leetcode 121 ,剑指offer 63

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 

~~~
示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

~~~

思路：动态规划

- dp[i]表示第以prices[i]结尾的最大利润
- **转移方程：dp[i] = max(dp[i-1],prices[i] - min(price[0:i]))前i-1日最大利润和第i日价格减去之前最低价格**
- 初始状态dp[0]=0，返回dp[n-1],n为dp数组长度
- 空间优化：由于dp[i]只与dp[i-1],prices[i]和min_price有关，可以用变量代替dp列表

~~~java
class Solution {
    public int maxProfit(int[] prices) {
        int min_price = Integer.MAX_VALUE;
        int profit = 0;

        for(int price : prices){
            min_price = Math.min(min_price,price);
            profit = Math.max(profit,price - min_price);
        }
        return profit;
    }
}
~~~

### 从前序和中序遍历构造二叉树

leetcode 105 ,剑指offer 07

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

思路：前序遍历第一个节点为根结点，然后在中序遍历中找到这个根结点，中序遍历根结点左边是左子树右边是右子树。然后分别对左右子树递归，构造二叉树。

细节，在中序遍历找根结点时，可以把中序遍历加入HashMap这样不用每次都要遍历数组找根结点。

~~~java
class Solution {
    private HashMap<Integer,Integer> map;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        map = new HashMap<>();
        for(int i = 0; i < inorder.length; i++){
            map.put(inorder[i],i);
        }
        return myBuildTree(preorder,inorder,0,preorder.length - 1,0,inorder.length -1);
        
    }

    public TreeNode myBuildTree(int[] preorder, int[] inorder,int pre_left,int pre_right,int in_left,int in_right){
        if(pre_left > pre_right) return null;
        int pre_root = pre_left;
        int in_root = map.get(preorder[pre_root]);

        TreeNode root = new TreeNode(preorder[pre_root]);
        int size = in_root - in_left;

        root.left = myBuildTree(preorder,inorder,pre_left + 1,pre_left + size,in_left,in_root - 1);
        root.right = myBuildTree(preorder,inorder,pre_left + 1 + size,pre_right,in_root + 1,in_right);

        return root;
    }
}
~~~

### 二叉树的中序遍历

leetcode 94

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。递归很简单，面试肯定考察非递归。

思路：中序遍历是左中右，先将所有root.left依次压入栈，依次弹出栈，那么就实现了左中，其中如果遇到有右结点的再令root = root.right,不断迭代，最后就是中序遍历

空间复杂度o(n)，还有一个莫里斯法空间复杂度o(1)

~~~java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stk = new Stack<>();
        //这个条件很精髓
        while(root != null || !stk.isEmpty()){
            while(root != null){
                stk.push(root);
                root = root.left;
            }

            root = stk.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
}
~~~

### 二叉树的层序遍历

leetcode 102 剑指offer 32

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 思路：新建一个队列，将根结点加入队列，每取出一个结点将他的左右孩子加入队列，迭代

~~~java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        //不能漏
        if(root == null) return res;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while(!q.isEmpty()){
            int n = q.size();
            List<Integer> temp = new ArrayList<>();
            for(int i = 0; i < n; i++){
                TreeNode node = q.poll();
                temp.add(node.val);
                if(node.left != null) q.offer(node.left);
                if(node.right != null) q.offer(node.right);
            }
            res.add(temp);
        }
        return res;
    }
}
~~~

### 二叉树之字形，锯齿状层序遍历

leetcode 102 剑指offer 32

~~~
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
~~~

思路：在102基础上，将ArrayList换成LinkedList，再加一个标志位用来判断是偶数层还是奇数层选用不同的打印顺序，偶数层直接在LinkedList后面加值，奇数层在LinkedList头结点加值。弄完一层以后把标志位反转。

~~~java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if(root == null) return res;
        Queue<TreeNode> nodeQueue = new LinkedList<>();
        nodeQueue.offer(root);
        //用一个标志位来判断是偶数层还是奇数层，从0开始偶数层从左到右打印，奇数层从右到左
        boolean isEvenLevel = true;
        while(!nodeQueue.isEmpty()){
            LinkedList<Integer> temp = new LinkedList<>();
            int size = nodeQueue.size();
            for(int i = 0; i < size; i++){
                TreeNode node = nodeQueue.poll();
                if(isEvenLevel){
                    temp.add(node.val);
                }else{
                    temp.addFirst(node.val);
                }

                if(node.left != null) nodeQueue.offer(node.left);
                if(node.right != null) nodeQueue.offer(node.right);
            }
            res.add(temp);
            isEvenLevel = ! isEvenLevel;
        }
        return res;
    }
}
~~~



### 环形链表

leetcode 141

给定一个链表，判断链表中是否有环。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

思路：一个快指针一次移动两步，一个慢指针一次移动一步，如果有环，他们一定会在环中相遇

如果是同一起点

~~~java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null)
            return false;
        ListNode slow = head;
        ListNode fast = head;

        while(true){
            if(fast == null || fast.next == null)
                return false;
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast) break;
        }
        return true;
    }
}
~~~

如果不是同一起点，这种写法开头一定要判断空的情况，总之不能让代码空指针

~~~java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null)
            return false;
        ListNode slow = head;
        ListNode fast = head.next;

        while(slow != fast){
            if(fast == null || fast.next == null)
                return false;
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
~~~



### 环形链表2

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。O(1)解决。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

思路：双指针数学推导，需要记忆数学规律，第一次遇到基本做不出来

- 设快指针一次走两步，走过的路程记为f;慢指针一次走一步，走过的路程记为s;**f= 2s**
- 头结点到链表入口前一个结点数量记为a,环长度记为b;
- 当快慢指针在环中第一次相遇，**f = s + nb**,可得**s= nb**
- 当指针在链表中正好走到入口，走过的长度为**a + nb**
- 只要再让s走a步即可到达入口
- 将快指针放到头结点，这次只让它一次走一步，等他第二次和慢指针相遇，那个结点就是入口结点

总结规律：快慢指针同时从head出发，第一次在环中相遇后，把快指针移到head然后一次走一步，再次相遇的结点就是链表入口

~~~java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head,slow = head;
        while(true){
            if(fast == null || fast.next == null)
                return null;
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow) break;
        }

        fast = head;
        while(slow != fast){
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}
~~~

### 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

思路：遍历字符串字符，每遇到左括号把它对应的右括号压入栈，遍历遇到右括号把它和弹栈出来的比较，如果不同提前返回false；

~~~java
class Solution {
    public boolean isValid(String s) {
        if(s.isEmpty()) return true;
        Stack<Character> stk = new Stack<>();
        for(char c : s.toCharArray()){
            if(c == '('){
                stk.push(')');
            }else if(c == '{'){
                stk.push('}');
            }else if(c == '['){
                stk.push(']');
            //不为左括号说明是右括号,还没遍历完栈就为空说明右括号多了数量就不匹配
            }else if(stk.isEmpty() || c != stk.pop()){
                return false;
            }
        }
        //再判断防止左括号多了
        return stk.isEmpty();
    }
}
~~~



### 合并两个有序链表*

leetcode 21 ,剑指offer 25

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

思路：用两个指针（结点本身就是指针）遍历两个链表，比较两个指针指向结点大小，两节点交替前进，直至遍历完两个链表

小技巧：可以引入一个伪头结点，方便最后返回结果

​				用一个cur指针在两个链表之间游走，建立链表，另两个用于比较，所以总共用到了三个指针

~~~java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        //cur就是一个穿针引线的作用
        ListNode cur = dummy;

        while(l1 != null && l2 != null){
            if(l1.val <= l2.val){
                cur.next = l1;
                l1 = l1.next;
            }else{
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        cur.next = l1==null ? l2 : l1;
        return dummy.next;
    }
}
~~~

### 链表中倒数第K个结点

剑指offer 22

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

思路：用双指针，不用统计链表长度。前指针先往后走k步，然后后指针和前指针一起往后走，当前指针为null时即后指针距离尾结点k-1,即倒数第k个

~~~java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        if(head == null || k == 0) return null;
        ListNode former = head;
        ListNode latter = head;

        for(int i = 0; i < k; i++){
            if( former == null) return null;
            former = former.next;
        }

        while(former != null){
            former = former.next;
            latter = latter.next;
        }
        return latter;
    }
}
~~~

### 两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

~~~
示例 1：
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
~~~

思路：一个队列具备的两个功能分别由两个栈来完成：栈A实现入队加入队尾功能，栈B实现出队删除队头功能



~~~java
class CQueue {
    Stack<Integer> stack_in;
    Stack<Integer> stack_out;
    public CQueue() {
       
            stack_in = new Stack<>();
            stack_out = new Stack<>();
        
    }
    
    public void appendTail(int value) {
        stack_in.push(value);
    }
    
    public int deleteHead() {
        if(stack_out.isEmpty()){
            while(!stack_in.isEmpty()){
                stack_out.push(stack_in.pop());
            }
        }
        if(stack_out.isEmpty()){
             return -1;
        }else{
            int deleteItem = stack_out.pop();
            return deleteItem;
        }
           
      
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
~~~

### 斐波那契

剑指offer 10

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.

思路：	状态转移方程：f(n) = f(n-1) +f(n-2);

~~~java
class Solution{
    public int fib(int n){
        if(n == 0) return 0;
        if(n == 1) return 1;
        int first = 0，second = 1;
        int sum = 0;
        for(int i=2;i<=n;i++){
            sum = first + second;
            first = second;
            second = sum;
        }
        return sum;
    }
}
~~~



### 青蛙跳台阶/爬楼梯

LeetCode 70 剑指offer 10 

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。

思路：	状态转移方程：f(n) = f(n-1) +f(n-2);

注意跳台阶当台阶数为0或1，跳法都是1.青蛙跳台阶和斐波那契就是初始值不一样其他都是一样的。

~~~java
class Solution {
    public int climbStairs(int n) {
        if(n == 0 || n == 1) return 1;
        int first = 1, second = 1;
        int sum = 0;
        for(int i = 2; i <= n; i++){
            sum = first + second;
            first = second;
            second = sum;
        }
        return sum;
    }
}
~~~

