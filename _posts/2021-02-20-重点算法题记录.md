---
layout:     post
title:      重点算法题记录
subtitle:   概述
date:       2021-02-20
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 算法
---

# 重点算法题记录

从上往下为字节后端考察频率，开始针对性刷题。

### 反转链表

剑指offer 24

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

思路：用两个指针迭代，遍历链表，遍历的时候偶反转两个节点

~~~java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null,cur = head;
        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
~~~

### 数组中的第k个最大元素

leetcode 215

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。即排序后从后往前第k个，相当于索引nums.length - k

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```



### 无重复字符的最长子串（滑动窗口）

leetcode 03 ,剑指offer 48

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

思路：双指针 i , j 加HashMap

- 右指针 j 遍历字符s，用一个HashMap记录每个字符最后一次出现的位置
- 更新左指针，保证 i + 1 和 j之间无重复的字符
- 那么最大值便是 j - i,在循环中不断更新这个最大值就行了

~~~ java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int i = -1, max = 0;
        HashMap<Character,Integer> map = new HashMap<>();
        for(int j = 0; j < s.length(); j++){
            char temp = s.charAt(j);
            if(map.containsKey(temp))
                //防止两个相同字符中间出现重复如abba,i不能开倒车
                i = Math.max(i,map.get(temp));
            map.put(temp,j);
            max = Math.max(max,j - i);
        }
        return max;
    }
}
~~~

### 买卖股票的最佳时机

leetcode 121 ,剑指offer 63

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 

~~~
示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

~~~

思路：动态规划

- dp[i]表示第以prices[i]结尾的最大利润
- **转移方程：dp[i] = max(dp[i-1],prices[i] - min(price[0:i]))前i-1日最大利润和第i日价格减去之前最低价格**
- 初始状态dp[0]=0，返回dp[n-1],n为dp数组长度
- 空间优化：由于dp[i]只与dp[i-1],prices[i]和min_price有关，可以用变量代替dp列表

~~~java
class Solution {
    public int maxProfit(int[] prices) {
        int min_price = Integer.MAX_VALUE;
        int profit = 0;

        for(int price : prices){
            min_price = Math.min(min_price,price);
            profit = Math.max(profit,price - min_price);
        }
        return profit;
    }
}
~~~

### 从前序和中序遍历构造二叉树

leetcode 105 ,剑指offer 07

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

思路：前序遍历第一个节点为根结点，然后在中序遍历中找到这个根结点，中序遍历根结点左边是左子树右边是右子树。然后分别对左右子树递归，构造二叉树。

细节，在中序遍历找根结点时，可以把中序遍历加入HashMap这样不用每次都要遍历数组找根结点。

~~~java
class Solution {
    private HashMap<Integer,Integer> map;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        map = new HashMap<>();
        for(int i = 0; i < inorder.length; i++){
            map.put(inorder[i],i);
        }
        return myBuildTree(preorder,inorder,0,preorder.length - 1,0,inorder.length -1);
        
    }

    public TreeNode myBuildTree(int[] preorder, int[] inorder,int pre_left,int pre_right,int in_left,int in_right){
        if(pre_left > pre_right) return null;
        int pre_root = pre_left;
        int in_root = map.get(preorder[pre_root]);

        TreeNode root = new TreeNode(preorder[pre_root]);
        int size = in_root - in_left;

        root.left = myBuildTree(preorder,inorder,pre_left + 1,pre_left + size,in_left,in_root - 1);
        root.right = myBuildTree(preorder,inorder,pre_left + 1 + size,pre_right,in_root + 1,in_right);

        return root;
    }
}
~~~

### 二叉树的中序遍历

leetcode 94

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。递归很简单，面试肯定考察非递归。

思路：中序遍历是左中右，先将所有root.left依次压入栈，依次弹出栈，那么就实现了左中，其中如果遇到有右结点的再令root = root.right,不断迭代，最后就是中序遍历

空间复杂度o(n)，还有一个莫里斯法空间复杂度o(1)

~~~java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stk = new Stack<>();
        //这个条件很精髓
        while(root != null || !stk.isEmpty()){
            while(root != null){
                stk.push(root);
                root = root.left;
            }

            root = stk.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
}
~~~

### 二叉树的层序遍历

leetcode 102

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 思路：新建一个队列，将根结点加入队列，每取出一个结点将他的左右孩子加入队列，迭代

~~~java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        //不能漏
        if(root == null) return res;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while(!q.isEmpty()){
            int n = q.size();
            List<Integer> temp = new ArrayList<>();
            for(int i = 0; i < n; i++){
                TreeNode node = q.poll();
                temp.add(node.val);
                if(node.left != null) q.offer(node.left);
                if(node.right != null) q.offer(node.right);
            }
            res.add(temp);
        }
        return res;
    }
}
~~~

