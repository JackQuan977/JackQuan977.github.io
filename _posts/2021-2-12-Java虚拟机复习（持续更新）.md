---
layout:     post
title:      Java虚拟机复习（持续更新）
subtitle:   概述
date:       2021-2-12
author:     QUanLi
header-img: img/post-bg-keybord.jpg
catalog: true
tags:
    - JVM
---

# Java虚拟机复习

 	JVM非常重要，持续更新复习

### JVM内存模型简介

- 堆——堆是所有线程共享的，主要用来存储对象。其中，堆可分为：*年轻代*和*老年代*两块区域。使用NewRatio参数来设定比例。对于年轻代，一个Eden区和两个Suvivor区，使用参数SuvivorRatio来设定大小
- Java虚拟机栈/本地方法栈——线程私有的，主要存放*局部变量表*，*操作数栈*，*动态链接*和*方法出口*等；
- 程序计数器——同样是线程私有的，记录当前线程的行号指示器，为线程的切换提供保障；
- 方法区——线程共享的，主要存储*类信息*、*常量池*、*静态变量*、*JIT编译后的代码*等数据。方法区理论上来说是堆的逻辑组成部分；
- 运行时常量池——是方法区的一部分，用于存放编译期生成的各种字面量和符号引用；

### 运行时常量池存储什么

​	存放编译期生成的各种字面量与符号引用

### 方法区和元空间、永久代什么关系有什么

​	《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 同时大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说**使用永久代来实现方法区**。因此，我们得到了结论，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。其他的虚拟机实现并没有永久代这一说法。在1.7之前在(JDK1.2 ~ JDK6)的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC分代来实现方法区内存回收。

​	对于Java8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。那么取代永久代的就是**元空间**。它可永久代有什么不同的？存储位置不同，永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。

### 为何移除永久代换成元空间实现方法区？

​	HotSpot 设计者为了，不为方法区专门编写内存管理代码，用GC分代回收管理方法区，，使用永久代，永久代逻辑上属于方法区，但是物理上是堆的一部分，容易造成内存溢出问题。JDK8完全抛弃永久代，使用元空间，在本地内存实现元空间。

### 栈中存放什么数据，堆中呢？

​	 堆内存用来存放由new创建的对象和数组。栈中存的是基本数据类型和堆中对象的引用。

### java内存模型（JMM）

​	java内存模型主要是保证**共享内存部分**的原子性、可见性、有序性，内存模型定义了共享内存中多线程程序读写宝座行为的规范。我们常说的JVM内存模式指的是JVM的内存分区；而Java内存模式是一种虚拟机规范。JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存（Main Memory）中**，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程读/写共享变量的副本。![image-20210213005712440](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210213005712440.png)

如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。

- 线程A把本地内存A中更新过的共享变量刷新到主内存中去。

- 线程B到主内存中去读取线程A之前已更新过的共享变量。

##### 线程之间如何通信、同步？

​	java并发采用的是**共享内存模型**

##### JMM内存模型三大特性

1. 原子性

   使用 synchronized 互斥锁来保证操作的原子性

2. 可见性

   volatile，会强制将该变量自己和当时其他变量的状态都刷出缓存。

   synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。

3. 有序性

   源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 ->最终执行的命令

   **重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性**

### 什么是类加载？何时类加载？类加载流程？

- 什么是类加载？：类加载就是将class文件字节码内容加载到内存，对数据进行校验解析初始化，最终形成可以被虚拟机直接使用的java类型，这个过程称为类加载机制
- 何时类加载？：使用new实例化对象，调用一个类型静态方法，读取一个类型的静态字段
- 类加载流程？：加载、验证、准备、解析、初始化、使用、卸载

### 什么是类加载器

​	类加载器就是把类文件加载到虚拟机中，将类加载阶段中的“通过一个类的全限定名获取该类的二进制字节流“这个动作放到JVM外部实现，以便让程序自己决定如何获取所需的类。

### 知道哪些类加载器。类加载器之间的关系？

​	加载一个Class类的顺序也是有优先级的，从底往上顺序是这样的

- BootStrap ClassLoader(启动类加载器)：它用来加载 Java 的核心库，负责加载存放存在java_home\lib目录下的，如rt.jar
- Extention ClassLoader(拓展类加载器):加载拓展jar包，一种java类库拓展机制
- App ClassLoader（应用程序类加载器）：指定classpath（用户类路径）下jar包，程序中默认类加载器
- Custom ClassLoader(自定义类加载器)

### 	 

### 类加载器的双亲委派了解么？

​	双亲委派就是一个类加载器收到类加载请求时，不会自己加载，而是把这个请求委托给父类加载器完成，每个层次都是如此，因此所有最终加载请求都会被传到最顶层启动类加载器，只有当父类加载器无法完成加载（搜索范围没有所需类），子加载器才会尝试自己加载。

​	好处是加载位于rt.jar包中的类时不管是哪个类加载器加载都会委托到启动类加载器加载，确保使用不同类加载器得到同样结果。起到一个隔离的作用，避免我们的代码影响JDK代码，保护java核心类库。比如用户自己写了一个名为java.lang.Object类，那么系统将出现多个Object类，java体系最基础的行为也无从保障，变得一片混乱。

### 结合 Tomcat 说一下双亲委派，Tomcat 如何打破双亲委派机制？

- 为何要打破双亲委派？

  首先, 来举个例子, 通常,一个tomcat要加载几个应用程序呢? 当然是n多个应用程序, 加入我们使用的都是spring的框架, 那我们能保证所有的应用程序都是用spring4 或者spring5 么? 不可能, 他可能既有spring4的项目, 又有spring5的项目. 那么tomcat在加载spring4项目的war包是, 会不会和spring5项目的war包冲突呢? 因为spring4, 和 spring5中有很多类的类名是一样的, 但是实现不一样. 如果都是交给父类加载器加载, 那么肯定只能加载一份. 也就是spring4和spring5的项目不能共存. 而实际上的情况呢? 我们的tomcat可以加在各种各样类型的war包, 相互之间没有影响. 他是怎么做到的呢?

- 如何打破？

  java项目在打war包的时候, tomcat自动生成的类加载器, 也就是说 , 每一个项目打成一个war包, tomcat都会自动生成一个类加载器, 专门用来加载这个war包. 而这个类加载器打破了双亲委派机制. 

### 如何判断对象已死？

- 引用计数器法

  在对象中添加一个引用计数器，每当有一个地方引用它，计数器加一。引用失效时，计数器值减一。

- 可达性分析算法（java使用）

  通过一系列称为“GC Roots”的根对象作为**起始节点集**，从这些节点开始根据引用关系向下搜索，搜索过程走过的路径称为“引用链”，如果某个对象到GC Roots之间没有任何引用链连接，如果从GC Roots到某个对象不可达时，证明此对象不可能再被使用，会被判定为可回收的对象。

  常见GC Roots

  - 方法区中类静态属性引用的变量，如java类的引用类型静态变量
  - 方法区中常量引用的对象，譬如字符串常量池里的引用
  - 所有被同步锁持有的对象

### ~~finalize( )方法~~

​	真正宣告一个对象死亡至少要经过两次标记过程，第一次发现没有与GC Roots相连接的引用链会被第一次标记，如果对象没有覆盖finalize()方法，或finalize()已被虚拟机调用过，那么虚拟机就认为没有必要执行finalize()。

​	finalize()是对象逃脱死亡的最后一次机会，但不推荐使用这个方法拯救对象，因为它运行代价高昂，不确定性太大。现在可以用强软弱虚引用代替他。

### java的引用

​	JDK 1.2后，java对引用概念进行了补充细分，将引用分为**强引用、软引用、弱引用、虚引用**。

- 强引用：程序中普遍存在的引用赋值，类似Object obj = new Object();这种引用关系，只要强引用关系存在，垃圾回收器永远不会回收掉被引用的对象。
- 软引用：还有用但非必须。被软引用关联的对象，在系统即将发生内存溢出前，会把这些对象纳入回收范围。
- 弱引用：用来描述非必须对象，只要垃圾回收器开始工作，无论当前内存是否足够，都会回收掉
- 虚引用：一个对象是否有虚引用存在完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象实例。一个对象被虚引用，只是为了这个对象被回收时有一个通知。

### 方法区回收什么

​	方法区主要回收废弃常量和不再使用的类型。例如字符串“java”曾经进入常量池，但是系统当前没有任何字符串对象是“java”,常量就会被清理出常量池

### 堆区如何分类

- **新生代**

  使用minor GC基于标记复制在Eden区、FromSpace、ToSpace之间复制

  - **Eden区**：新建对象加入Eden区，Eden区满触发minor GC，这时把把存活对象移入survivor区
  - **survivor区**
    - **FromSpace**:
    - **ToSpace**:

- **老年代**：存放多次minor GC存活对象，老年代存活时间长稳定，用标记清除、标记整理

### 垃圾回收有哪些算法 



1. **标记-清除（最基础）**：标记出要回收对象，统一回收。
   - 执行效率不稳定，如果Java堆中包含大量对象，大部分都要回收，会进行大量标记清除操作，执行效率随对象大小增长而降低。
   - 内存空间碎片化
2. **标记-复制（优先采用）**：内存容量分成两块，标记活着的对象复制到另一块上。
   	- 解决碎片化问题、解决标记清除效率问题
   	- 浪费百分之50空间
3. **标记-整理**：标记-复制在对象存活率高时，效率降低。标记-整理让存活对象都向内存空间一端移动，然后直接清理掉边界以外内存。





​	

