---
layout:     post
title:      Java虚拟机复习（持续更新）
subtitle:   概述
date:       2021-2-12
author:     QUanLi
header-img: img/post-bg-keybord.jpg
catalog: true
tags:
    - JVM
---

# Java虚拟机复习

 	JVM非常重要，持续更新复习

### JVM内存模型简介

- 堆——堆是所有线程共享的，主要用来存储对象。其中，堆可分为：*年轻代*和*老年代*两块区域。使用NewRatio参数来设定比例。对于年轻代，一个Eden区和两个Suvivor区，使用参数SuvivorRatio来设定大小
- Java虚拟机栈/本地方法栈——线程私有的，主要存放*局部变量表*，*操作数栈*，*动态链接*和*方法出口*等；
- 程序计数器——同样是线程私有的，记录当前线程的行号指示器，为线程的切换提供保障；
- 方法区——线程共享的，主要存储*类信息*、*常量池*、*静态变量*、*JIT编译后的代码*等数据。方法区理论上来说是堆的逻辑组成部分；
- 运行时常量池——是方法区的一部分，用于存放编译期生成的各种字面量和符号引用；

### 运行时常量池存储什么

​	存放编译期生成的各种字面量与符号引用

### 方法区和元空间、永久代什么关系有什么

​	《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 同时大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说**使用永久代来实现方法区**。因此，我们得到了结论，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。其他的虚拟机实现并没有永久代这一说法。在1.7之前在(JDK1.2 ~ JDK6)的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC分代来实现方法区内存回收。

​	对于Java8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。那么取代永久代的就是**元空间**。它可永久代有什么不同的？存储位置不同，永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。

### 为何移除永久代换成元空间实现方法区？

​	HotSpot 设计者为了，不为方法区专门编写内存管理代码，用GC分代回收管理方法区，，使用永久代，永久代逻辑上属于方法区，但是物理上是堆的一部分，容易造成内存溢出问题。JDK8完全抛弃永久代，使用元空间，在本地内存实现元空间,解决了永久代的OOM问题。

### 栈中存放什么数据，堆中呢？

​	 堆内存用来存放由new创建的对象和数组。栈中存的是基本数据类型和堆中对象的引用。

### java内存模型（JMM）

​	java内存模型主要是保证**共享内存部分**的原子性、可见性、有序性，内存模型定义了共享内存中多线程程序读写宝座行为的规范。我们常说的JVM内存模式指的是JVM的内存分区；而Java内存模式是一种虚拟机规范。JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存（Main Memory）中**，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程读/写共享变量的副本。![image-20210213005712440](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210213005712440.png)

如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。

- 线程A把本地内存A中更新过的共享变量刷新到主内存中去。

- 线程B到主内存中去读取线程A之前已更新过的共享变量。

##### 线程之间如何通信、同步？

​	java并发采用的是**共享内存模型**

##### JMM内存模型三大特性

1. 原子性

   使用 synchronized 互斥锁来保证操作的原子性

2. 可见性

   volatile，会强制将该变量自己和当时其他变量的状态都刷出缓存。

   synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。

3. 有序性

   源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 ->最终执行的命令

   **重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性**

### 什么是类加载？何时类加载？类加载流程？

- 什么是类加载？：类加载就是将class文件字节码内容加载到内存，将其放在运行时数据区域的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。
- 何时类加载？：使用new实例化对象，调用一个类型静态方法，读取一个类型的静态字段
- 类加载流程？：
  - 加载：查找路径找到相应class文件然后导入
  - 验证：检查class文件正确性
  - 准备：给静态变量分配空间
  - 解析：将常量池中的符号引用换成直接引用。符号引用理解为一个标识，直接引用指向内存中的地址。
  - 初始化：对静态变量初始化

### 什么是类加载器

​	对于任何一个类都要由加载它的类加载器和这个类本身确立在JVM中的唯一性，每一个类加载器都有一个独立的类名称命名空间，类加载器就是根据全限定名将class文件加载到jvm内存，然后再转化为class对象。

### 知道哪些类加载器。类加载器之间的关系？

​	加载一个Class类的顺序也是有优先级的，从底往上顺序是这样的

- BootStrap ClassLoader(启动类加载器)：它用来加载 Java 的核心库，负责加载存放存在java_home\lib目录下的，如rt.jar
- Extention ClassLoader(拓展类加载器):加载拓展jar包，一种java类库拓展机制
- App ClassLoader（应用程序类加载器）：指定classpath（用户类路径）下jar包，程序中默认类加载器，，我们可以直接使用
- Custom ClassLoader(自定义类加载器)

### 	 

### 类加载器的双亲委派了解么？

​	双亲委派就是一个类加载器收到类加载请求时，不会自己加载，而是把这个请求委托给父类加载器完成，每个层次都是如此，因此所有最终加载请求都会被传到最顶层启动类加载器，只有当父类加载器无法完成加载（搜索范围没有所需类），子加载器才会尝试自己加载。

​	好处是加载位于rt.jar包中的类时不管是哪个类加载器加载都会委托到启动类加载器加载，确保使用不同类加载器得到同样结果。起到一个隔离的作用，避免我们的代码影响JDK代码，保护java核心类库。比如用户自己写了一个名为java.lang.Object类，那么系统将出现多个Object类，java体系最基础的行为也无从保障，变得一片混乱。

### 结合 Tomcat 说一下双亲委派，Tomcat 如何打破双亲委派机制？

- 为何要打破双亲委派？

  首先, 来举个例子, 通常,一个tomcat要加载几个应用程序呢? 当然是n多个应用程序, 加入我们使用的都是spring的框架, 那我们能保证所有的应用程序都是用spring4 或者spring5 么? 不可能, 他可能既有spring4的项目, 又有spring5的项目. 那么tomcat在加载spring4项目的war包是, 会不会和spring5项目的war包冲突呢? 因为spring4, 和 spring5中有很多类的类名是一样的, 但是实现不一样. 如果都是交给父类加载器加载, 那么肯定只能加载一份. 也就是spring4和spring5的项目不能共存. 而实际上的情况呢? 我们的tomcat可以加在各种各样类型的war包, 相互之间没有影响. 他是怎么做到的呢?

- 如何打破？

  java项目在打war包的时候, tomcat自动生成的类加载器, 也就是说 , 每一个项目打成一个war包, tomcat都会自动生成一个类加载器, 专门用来加载这个war包. 而这个类加载器打破了双亲委派机制. 

### 如何判断对象已死？

- 引用计数器法

  在对象中添加一个引用计数器，每当有一个地方引用它，计数器加一。引用失效时，计数器值减一。问题在于如果**出现对象的循环引用时GC无法回收**。

- 可达性分析算法（java使用）

  通过一系列称为“GC Roots”的根对象作为**起始节点集**，从这些节点开始根据引用关系向下搜索，搜索过程走过的路径称为“引用链”，如果某个对象到GC Roots之间没有任何引用链连接，如果从GC Roots到某个对象不可达时，证明此对象不可能再被使用，会被判定为可回收的对象。解决了循环引用问题。

  常见GC Roots

  - 虚拟机栈（本地变量表）中引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中引用的对象

### ~~finalize( )方法~~

​	真正宣告一个对象死亡至少要经过两次标记过程，第一次发现没有与GC Roots相连接的引用链会被第一次标记，如果对象没有覆盖finalize()方法，或finalize()已被虚拟机调用过，那么虚拟机就认为没有必要执行finalize()。

​	finalize()是对象逃脱死亡的最后一次机会，但不推荐使用这个方法拯救对象，因为它运行代价高昂，不确定性太大。现在可以用强软弱虚引用代替他。

### java的引用

​	JDK 1.2后，java对引用概念进行了补充细分，将引用分为**强引用、软引用、弱引用、虚引用**。

- 强引用：程序中普遍存在的引用赋值，类似Object obj = new Object();这种引用关系，只要强引用关系存在，垃圾回收器永远不会回收掉被引用的对象。
- 软引用：还有用但非必须。被软引用关联的对象，在系统即将发生内存溢出前，会把这些对象纳入回收范围。
- 弱引用：用来描述非必须对象，只要垃圾回收器开始工作，无论当前内存是否足够，都会回收掉
- 虚引用：一个对象是否有虚引用存在完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象实例。一个对象被虚引用，只是为了这个对象被回收时有一个通知。

### 方法区回收什么

​	方法区主要回收废弃常量和不再使用的类型。例如字符串“java”曾经进入常量池，但是系统当前没有任何字符串对象是“java”,常量就会被清理出常量池

### 堆区如何分类

![image-20210214185728672](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210214185728672.png)

- **新生代**

  使用minor GC基于**标记复制**在Eden区、FromSpace、ToSpace之间复制。执行流程是，把Eden区+FromSpace存活对象放入ToSpace，清空Eden区+FromSpace，将FromSpace和ToSpace互换。

  - **Eden区**：新建对象加入Eden区，Eden区满触发minor GC，这时把把存活对象移入survivor区
  - **survivor区**：这两个区域同一时间只有一个区域有数据。
    - **FromSpace**:
    - **ToSpace**:

- **老年代**：老年代的对象一般**来自于新生代中的长期存活对象。这里有一概念叫做**年龄阈值**，每个对象定义了年龄计数器，经过一次 Minor GC （在交换区）后年龄加1，对象年龄达到***15次***后将会晋升到老年代，老年代空间不够时进行 ***Full GC***。当然这个参数仍是可以通过 JVM 参数（***-XX:MaxTenuringThreshold***，默认15）来调整，用**标记清除、标记整理**

- 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（***-XX:PretenureSizeThreshold=30m\***，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。

### 垃圾回收有哪些算法 



1. **标记-清除（最基础）**：标记出要回收对象，统一回收。
   - 执行效率不稳定，如果Java堆中包含大量对象，大部分都要回收，会进行大量标记清除操作，执行效率随对象大小增长而降低。
   - 内存空间碎片化
2. **标记-复制（优先采用）**：内存容量分成两块，标记活着的对象复制到另一块上。
   	- 解决碎片化问题、解决标记清除效率问题
   	- 浪费百分之50空间
3. **标记-整理**：标记-复制在对象存活率高时，效率降低。标记-整理让存活对象都向内存空间一端移动，然后直接清理掉边界以外内存。
4. **分代回收**：新生代用标记-复制，因为每次存活的相对少，只要标记少量存活的复制。老年代用主要是标记整理。

### Java中有内存泄露吗？

​	内存泄露是指，不再使用的对象一直占据在内存中。

​	当长生命周期对象持有短生命周期对象的引用就很可能发生内存泄露。

### JVM有哪些垃圾回收器

### GC 的全流程

​	新生对象在Eden区分配，Eden区满了触发Minor GC，然后把Eden区+FromSpace存活对象放入ToSpace，清空Eden区+FromSpace，将FromSpace和ToSpace互换。对象在Survivor区每经历一次Minor GC年龄加一，默认达到十五进入老年代，大小超过Eden区的对象直接进入老年代。老年代满了触发Full GC，Full GC速度比Minor GC慢十倍以上，且会停止所有线程进行GC，Stop the world，要尽量避免。

### GC 中老年代用什么回收方法？ 

​	老年代用标记-整理，因为老年代对象存活率较高，用标记复制会有很多复制操作，效率低。标记清除会产生大量内存碎片。

​	而用标记-整理将存活对象压缩到内存一边，紧凑地排列在一起然后对边界以外内存回收，解决了标记-清除产生大量碎片的问题，但仍需要进行局部对象移动。

### 说一下JVM调优工具



### jvm调优参数



