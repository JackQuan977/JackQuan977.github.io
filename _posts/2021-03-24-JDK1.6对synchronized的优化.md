---
layout:     post
title:      JDK1.6对synchronized的优化
subtitle:   概述
date:       2021-03-24
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 多线程
---

### JDK1.6对synchronized的优化

​	JDK1.6 对锁的实现引入了大量的优化来减少锁操作的开销，如: **偏向锁**、**轻量级锁**、**自旋锁**、**适应性自旋锁**、**锁消除**、**锁粗化** 等等技术。

锁主要存在四中状态，依次是：

1. 无锁状态
2. 偏向锁状态
3. 轻量级锁状态
4. 重量级锁状态

锁🔐会随着竞争的激烈而逐渐升级。

### Java对象头

​	java对象头由**Mark Word、指向类的指针、数组长度（只有数组对象才有）**组成。

##### Mark Word

​	Mark Word记录了对象和锁有关的信息，默认存储对象的**hashcode、GC分代年龄、和锁标志位信息**。当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。

![image-20210324195201211](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210324195201211.png)

### 无锁状态

​	无锁没有对资源进行锁定，所有线程都可以访问并修改一个资源，但同时只有一个线程可以修改成功。CAS原理及应用即是无锁的实现。

### 偏向锁

​	偏向锁是一段同步代码一直被一个线程访问，锁总是由同一线程多次获得，不存在多线程竞争，那么该线程会会自动获取锁，其目标就是在只有一个线程执行同步代码块时能够提高性能。

​	当一个线程访问同步代码块并获取锁时，JVM发现同步锁处于偏向状态，Mark Word中记录的线程id就是这个线程自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。

​	引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

### 轻量级锁

​	当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。

​	当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。

​	轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。

### 重量级锁

​	自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，重量级锁未抢到锁的线程都会被阻塞。

### 总结

​	**偏向锁通过对比Mark Word里的线程ID解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。**