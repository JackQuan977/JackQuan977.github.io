---
layout:     post
title:      三次握手、四次挥手复习
subtitle:   概述
date:       2021-03-03
author:     QuanLi
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - 计算机网络
---

# 三次握手、四次挥手复习

​	需要对三次握手、四次挥手的过程有深入理解，**能够画出状态图**，理解各个状态的含义。

### **TCP连接的建立（三次握手）**

​	三次握手就是建立一个TCP连接时，需要客户端和服务器总共发送三个包。三次握手的目的是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面可靠性传送做准备。实质上就是连接服务器指定端口，建立TCP连接，并同步双方序列号和确认号，交换TCP窗口大小信息。

##### 三次握手具体过程

​	一开始客户端处于closed状态，服务端处于listen状态。

- **第一次握手**：客户端给服务端发送一个SYN报文 ，并指明客户端的初始化序列ISN，SYN=1，seq=x,ACK=0.此时客户端处于SYN-SENT（同步已发送）的状态
- **第二次握手**：服务端收到客户端的SYN报文后，会以自己的SYN报文作为应答，为自己设一个初始序号seq=y,确认号ack=x+1,此时TCP服务端处于SYN-RCVD（同步已收到），**SYN=1,ACK=1,seq=y,ack=x+1**.
- **第三次握手**：客户端收到一个SYN报文后，会发送一个ACK报文，将服务端的seq+1作为ack，表示接收到的是服务端的SYN报文，此时客户端处于EATAB-LISTEN（已建立连接）状态，ACK=1，seq=x=1,ack=y+1;此时双方已经建立了连接。这次报文可以携带数据。

![image-20210303202217275](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210303202217275.png)

##### 为什么是三次握手不是两次？

- 第一次握手：客户端发送网络包，服务端收到了。服务端得到结论：客户端发送能力、服务端的接收能力正常  第二次握手：服务端发送包客户端收到了。客户端得出结论：服务端接收和发送能力、客户端接收和发送能力正常。**此时服务端可以确认客户端的发送能力，但是无法确认客户端的接收能力,所以需要第三次握手**  第三次握手:客户端发包，服务端收到。此时服务端知道客户端收到了自己第二次握手发送的网络包，客户端接收的接收也是正常的。 因此至少需要三次握手才能确认双方的接收发送能力都是正常的。  

- **三次握手还可以防止已失效的客户端连接请求突然又传送到了服务端。**如果客户端发出连接请求但在某些网络结点长时间滞留了，延误到连接释放后某个时间到达服务端。服务端收到这个延误的连接请求后误认为客户端又发出一次连接请求，于是向客户端发出确认报文，同意建立连接，如果不采用三次握手，两次的话这时候就会成功建立连接，此时客户端忽略服务端发来的确认，也不发送数据，就会浪费服务端的资源了。

##### 什么是半连接队列？什么是全连接队列

​	**服务器第一次收到客户端的SYN之后，就会处于SYN_RCVD（同步收到）的状态，此时双方还没有完全建立连接，服务器会把此种状态下的请求连接放在一个队列里，这种队列称为半连接队列。**还有一个全连接队列，就是三次握手已经完成，建立起连接的就会放在全连接队列中，队列满了就会发生丢包现象。  服务器发送完SYN-ACK包，如果没有收到客户的确认包，服务器就会进行首次重传，等一段时间还未收到就会进行二次重传。重传次数如果超过系统规定得最大次数，系统就将该连接信息从半连接队列中删除，注意每次重传等待时间不相同，一般是指数增长如1,2,4,8s

##### **初始化序列号seq是固定的吗？**

​	当一端为建立连接而发送它的SYN时，它为连接选择一个初试序号。ISN的值随时间变化，因此，每个连接都有不同的ISN。ISN可以看做一个32比特的计数器，每4ms加一，这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送。  三次握手的一个重要目的就是客户端和服务器交换ISN，以便让对方知道接下来接收数据如何按序列号接收数据。如果ISN是固定的攻击者很容易猜出后续的的确认号，因此ISN是动态生成的。

##### SYN洪泛攻击是什么，怎么解决？

​	SYN攻击就是客户端**伪造大量不存在的IP地址，并向服务器不断发送SYN请求连接的包**，服务器就会回复确认包，并等待客户端确认，因为源地址并不存在，因此服务器需要不断重发直到超时，**这些伪造的SYN包将会长时间占用半连接队列**，导致正常的SYN请求反而因为队列满了被丢弃。  服务器端资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以第一次握手不得不接受SYN报文，所以服务器特别容易受SYN洪泛攻击。  监测SYN攻击也很方便，当你在服务器看到大量半连接状态时，特别是IP地址是随机的，基本上可以断定服务器受到了SYN攻击。常见防御方法有：缩短超时时间、增加最大半连接数、过滤网关防护和SYN cookies技术。

### 四次挥手具体过程

​	释放一个TCP连接要发送四个包，所以又被称为四次挥手。这是由TCP的半关闭造成的。所谓半关闭就是TCP提供了一端结束它的发送后还能接收另一方的数据的能力。刚开始双方都处于EATABLISHED 状态，加入客户端发起关闭请求，具体过程如下。

- **第一次挥手**：客户端发送一个FIN报文，报文中会指定一个序号seq,它是前面已经传送过得数据最后一个字节序号加一。此时客户端处于FIN-WAIT-1转态，等待服务器的确认。FIN=1，seq=u
- **第二次挥手**：服务端收到FIN报文后，会发送ACK报文，确认号是u+1表明已经收到客户端的报文，而这个报文本身的序号是v，此时服务端处于CLOSED-WAIT（关闭等待）状态。ACK=1.seq=v,ack=u+1。此时TCP处于半关闭状态，即客户端已经没有数据要发送，但服务器发送数据客户端还是得接收。客户端到服务器连接释放，客户端收到服务器确认后进入FIN-WAIT-2状态，等待服务器发送连接释放报文。
- **第三次挥手**：如果服务端也想断开连接，那就和客户端第一次挥手一样，发送FIN报文，且指定一个序号w，且还要重复上次的确认号u+1,此时服务端处于LAST-ACK(最后确认)状态，  FIN=1,ACK=1,seq=w,ack=u+1
-  **第四次挥手**：客户端收到FIN报文后，一样发送一个ACK报文作为应答，且把服务器序号w+1作为确认号，序号设为U+1.此时客户端处于TIME-WAIT状态，等待2MS后进入CLOSED状态。ACK=1,seq=u+1,ack=w+1

![image-20210303204657396](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210303204657396.png)

##### **为什么挥手要四次**

​	**当关闭连接时，服务端收到FIN报文时，很可能数据还没有传完，不会立即关闭SOCKET，所以先回复一个ACK告诉客户端你发送的FIN报文我收到了，只有等我服务端的报文都发完了，我才能发送FIN报文，因此不能一起发送。**所以需要四次挥手。当一方向另一方发送FIN报文意味着这方向上不再有数据流动。

##### 为什么客户端最后要等待2MSL

​	保证客户端发送的最后一个ACK报文能到达服务端，这个ACK报文可能丢失，使得处于LAST-ACK状态的服务端收不到对+ACK报文段的确认，所以服务端会超时重传这个FIN+ACK报文段，客户端在2MSL内会收到这个重传的报文段，客户端就会重传一次确认，客户端重新启动2MS计时器。如果客户端不在TIME—WAIT状态等待一段时间，而是在发送完ACK报文后立即释放连接就不会收到服务端重传的FIN+ACK报文了，这样服务端就无法正常进入CLOSED状态了。 **TIME-WAIT状态就是用来重发可能丢失得ACK报文。**