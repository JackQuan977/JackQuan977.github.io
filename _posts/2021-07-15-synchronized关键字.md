---
layout:     post
title:      synchronized关键字
subtitle:   概述
date:       2021-07-15
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - JavaSE
---

# synchronized关键字

​	synchronized 这个关键字的重要性不言而喻，几乎可以说是并发、多线程必须会问到的关键字了。**synchronized 会涉及到锁、升级降级操作、锁的撤销、对象头等。**所以理解 synchronized 非常重要

## 浅析 synchronized

​	`synchronized` 是 Java *并发模块*非常重要的关键字，它是 Java 内建的一种同步机制，代表了某种内在锁定的概念，当一个线程对某个`共享资源`加锁后，其他想要获取共享资源的线程必须进行等待，synchronized 也具有互斥和排他的语义。

​	synchronized 也是一种独占的关键字，但是它这种独占的语义更多的是为了增加线程安全性，通过独占某个资源以达到互斥、排他的目的。

​	在了解了排他和互斥的语义后，我们先来看一下 synchronized 的用法，先来了解用法，再来了解底层实现。

## synchronized 的使用

关于 synchronized 想必你应该都大致了解过

- **synchronized 修饰实例方法**，相当于是对类的实例进行加锁，进入同步代码前需要获得当前实例的锁
- **synchronized 修饰静态方法**，相当于是对类对象进行加锁
- **synchronized 修饰代码块**，相当于是给对象进行加锁，在进入代码块前需要先获得对象的锁

~~~java
class A{
	public void synchronized f1(){}
    public static void synchronized f2(){}
}
~~~

​	上面使用synchronized等价于下面代码

~~~java
class A{
	public void f1(){
        synchronized(this){
            ...
        }
    }
    public static void f2(){
        synchronized(A.class){
            ...
        }
    }
}
~~~

​		**所以对于非静态函数，锁其实是加在对象上面的。对于静态成员函数锁是加在类上的。**一个是对象锁一个是类锁。

​		所以如果一个静态函数和一个非静态函数都加了synchronized，分别被两个线程调用，不会互斥，因为是两把不同的锁。

## synchronized 底层原理

​	synchronized 的代码块是由一组 **monitorenter/monitorexit** 指令实现的。而**`Monitor` 对象是实现同步的基本单元。**

### 啥是 `Monitor` 对象呢？

​	**任何对象都关联了一个管程，管程属于一种进程同步互斥工具**，**是一种同步原语**

​	管程提供了一种排他访问机制，这种机制也就是 `互斥`。互斥保证了在每个时间点上，最多只有一个线程会执行同步方法。

所以你理解了 **Monitor 对象其实就是使用管程控制同步访问的一种对象。**

​	**所以Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。**

### 对象内存布局

在 `hotspot` 虚拟机中，对象在内存中的布局分为三块区域：

- `对象头(Header)`
- `实例数据(Instance Data)`
- `对齐填充(Padding)`

这三块区域的内存分布如下图所示

![image-20210715212512021](https://i.loli.net/2021/07/15/YfbyPSUm8V5BXQc.png)

#### 对象头 Header

​	对象头 Header 主要包含 **MarkWord** 和对象指针 **Klass Pointer**，如果是数组的话，还要包含数组的长度。

​	Mark Word记录了对象和锁有关的信息，默认存储对象的**hashcode、GC分代年龄、和锁标志位信息**。



![image-20210715212736730](https://i.loli.net/2021/07/15/pDXQlRFJ4jBw8kt.png)

### 锁的升级流程

​	先来个大体的流程图来感受一下这个过程，然后下面我们再分开来说

### 无锁

​	`		无锁状态`，无锁即没有对资源进行锁定，所有的线程都可以对同一个资源进行访问，但是只有一个线程能够成功修改资源。

![image-20210715213052113](https://i.loli.net/2021/07/15/8NFUuHEbLOhsaxS.png)

​	无锁的特点就是在循环内进行修改操作，线程会不断的尝试修改共享资源，直到能够成功修改资源并退出，在此过程中没有出现冲突的发生，这很像我们在之前文章中介绍的 CAS 实现，**CAS 的原理和应用就是无锁的实现**。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。

### 偏向锁

​	HotSpot 的作者经过研究发现，**大多数情况下，锁不仅不存在多线程竞争**，**还存在锁由同一线程多次获得的情况**，偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。

![image-20210715213311088](https://i.loli.net/2021/07/15/zURuKMxl3QHkOF1.png)

**偏向锁获取过程**

1. 首先线程访问同步代码块，会通过检查对象头 Mark Word 的`锁标志位`判断目前锁的状态，如果是 01，说明就是无锁或者偏向锁，然后再根据`是否偏向锁` 的标示判断是无锁还是偏向锁，如果是无锁情况下，执行下一步
2. **线程使用 CAS 操作来尝试对对象加锁**，如果使用 CAS 替换 ThreadID 成功，就说明是第一次上锁，那么当前线程就会获得对象的偏向锁，此时会在对象头的 Mark Word 中记录当前线程 ID 和获取锁的时间 epoch 等信息，然后执行同步代码块。

3. 等到下一次线程在**进入和退出同步代码块时就不需要进行 `CAS` 操作进行加锁和解锁**，只需要简单判断一下对象头的 **Mark Word 中是否存储着指向当前线程的线程ID**

### 轻量级锁

​	是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，**其他线程会通过自旋CAS的形式尝试获取锁，不会阻塞，从而提高性能。**

​	若当前只有一个等待线程，则该线程通过自旋进行等待。**但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。**

### 重量级锁

​	升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，**此时等待锁的线程都会进入阻塞状态。**

![image-20210715214806761](https://i.loli.net/2021/07/15/lBp9fDGsSFH7xAn.png)