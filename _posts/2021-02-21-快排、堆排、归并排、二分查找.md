---
layout:     post
title:      快排、堆排、归并排、二分查找
subtitle:   概述
date:       2021-02-21
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 算法
---

# 快排、堆排、归并排、二分查找整理

![Image](C:\Users\ql\AppData\Local\Temp\Image.png)

### 快排

思路：将要排序的数据分割成独立的两部分，保证一部分数据比另一部分小，然后对这两部分进行递归，进行相同的处理，最后直到有序。

我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 nn 的问题我们都划分成 11 和 n - 1n−1，每次递归的时候又向 n - 1n−1 的集合中递归，这种情况是最坏的，时间代价是 O(n ^ 2)O(n 
2)。

大部分时候快排是选快排，但是没有完美的排序算法，即使是快速排序法，也只是整体性能上优秀，也存在排序不稳定、需要大量辅助空间、对少量数据排序没有优势这些缺点。

~~~java
public  static void quicksort(int[] arr,int L,int R){
        int i = L;
        int j = R;
        int pivot = arr[(L + R)/2];
        while (i <= j){
            //扫描左边比支点大的
            while (pivot > arr[i]){
                i++;
            }
            //扫描右边比支点小的
            while (pivot <arr[j]){
                j--;
            }

            if(i <= j){
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                i++;
                j--;
            }
        }
		//上面的1排序已经保证了，支点左边比支点小，支点右边比支点大，这时候i和j都在支点处交汇
        if(j >= L)
            quicksort(arr,L,j);
        if(i <= R)
            quicksort(arr,i,R);

    }
~~~

### 堆排

思路：

- 堆是完全二叉树，分为大顶堆和小顶堆，位于根部的不是最大就是最小

- 完全二叉树特性：左子节点位置 = 当前父节点位置两倍+1

  ​								右子节点位置 = 当前父节点位置两倍+2

  ![image-20210221202639387](C:\Users\ql\AppData\Roaming\Typora\typora-user-images\image-20210221202639387.png)

- 用数组存储堆，是按层序遍历来存储的

- 每次建堆，根结点是最大，然后将根结点和数组最后一个元素交换，这样不断建堆交换建堆交换，最后得到的就是有序数组

- 比较父节点是否大于子节点，如果大于就交换，直到一趟建堆完成

- 往往从数组最后一个元素来进行建堆，完成一次建堆之后，最大值在首位





