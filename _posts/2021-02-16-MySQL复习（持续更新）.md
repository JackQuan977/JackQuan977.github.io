---
layout:     post
title:     	MySQL复习（持续更新）
subtitle:   概述
date:       2021-02-15
author:     QuanLi
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 数据库
---

# MySQL

### 非关系型数据库和关系型数据库的区别？

关系型数据库：

- 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
- 数据一致性：基于ACID原则

非关系型数据库：

- 性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
- 可拓展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展

### 事 务 的 四 大 特 性 了 解 么 **?** 

原子性：一个事务被视为一个不可分割的最小工作单元。要么都成功要么都失败

一致性：数据库从一个一致状态转到另一个一致状态，不会读到中间过程

隔离性：通常来说一个事务的修改在提交前，对其他事务不可见

持久性：一旦事务提交，其所做修改永远保存在数据库中。



### **MySQL** 事 务 隔 离 级 别 ？ 默 认 是 什 么 级 别 ？

**MySQL 事 务 隔 离 级 别 ？**

- 未提交读（read uncommitted):   事务中的修改即使没有提交对其他事务也是可见的。**会出现脏读、不可重复读、幻读**。
- 提交读（read committed):   一个事务未提交前，对其他事务不可见。也称为不可重复读。因为两次执行相同查询结果可能不一样.**会出现不可重复读、幻读**。
- 可重复读（repeatable read/**默认**):   保证一个事务多次读取结果一样。**会出现幻读**。
- 可串行化（serializable）：强制事务串行执行，避免幻读。会在读的每一行上加锁实际很少用。

**默 认 是 什 么 级 别 ？**

默认可重复读，InnoDB在可重复读隔离级别下使用了Gap Lock（间隙锁）算法，使得InnoDB不仅锁定查询涉及的行，还对中间间隙锁定，防止幻影行插入。所以InnoDB使用可重复读的同时又避免了幻读。

### 事务并发带来的问题

- 脏读：一个事务还没提交就被其他事务访问到这个数据。
- 丢失修改：两个事务同时修改一个数据，其中一个修改丢失。
- 不可重复读：一个事务多次访问同一数据，事务还没结束，此时另一个事务访问修改数据，导致第一个事务两次读取不一样。
- 幻读：一个事务读取数据，另一个事务加了一些数据，第一个事务突然发现一些原本不存在的数据。



### 乐 观 锁 与 悲 观 锁 的 区 别 **?** 

### MySQL 数据库两种存储引擎的区别? 

- InnoDB支持事务，MyISAM不支持事务
- InnoDB支持外键，MyISAM不支持外键
- InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持
- InnoDB支持表、行级锁，而MyISAM支持表级锁。
- InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引



### MySQL有哪些索引

- B+树索引：是目前大多数MySQL默认的索引方式

- 哈希索引：查找速度快，时间复杂度为o（1），不支持排序分组，只支持精确查找，不支持范围查找。适用于绝大多数查询需求为单条记录的。

- 全文索引：innodb不支持全文索引，MyISAM支持

  

### 聚集索引和非聚集索引的区别？非聚集索引一定回表查询吗? 

​	聚集索引和非聚集索引的根本区别是**表记录的排列顺序和与索引的排列顺序是否一致**。

**聚集索引表记录顺序和索引顺序一致**，一个表中只能有一个聚集索引

- 优点是查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。
- 缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排， 降低了执行速度。聚集索引会降低 insert，和update操作的性能，所以，是否使用聚集索引要全面衡量。建议使用聚集索引的场合为：
   a. 此列包含小数目不同值；
   b. 经常搜索范围值的列；
   c. 不频繁更新。







**非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致**

- 聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针的方式。
   非聚集索引比聚集索引层次多，添加记录不会引起数据顺序的重组。
   建议使用非聚集索引的场合为：
   a. 此列包含了大数目不同的值；
   b. 查询的结束返回的是少量的结果集；
   c. order by 子句中使用了该列。

  

  非聚集索引一定回表查询吗? 

  不一定，如果查询语句的字段全部命中了索引，那么就不必再进行回表查询

### 为 什 么 索 引 能 提 高 查 询 速 度 **?** 

### 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？(使用索引一定能提高查询性能吗? ) 

### 索 引 底 层 的 数 据 结 构 了 解 么 ？ **Hash** 索 引 和 **B+**树 索 引 优 劣 分 析 

### B+树做索引比B树和红黑树好在哪里？ 

​	B树、B+树、红黑树都是**平衡查找树**，查询效率上讲平均都是O(log(n)),使用什么哪种数据结构，肯定是出于提高数据库的查询效率的考虑。衡量查询效率的主要标准就是磁盘I/O的次数。索引本身也很大，不可能全放在内存，有部分会存储在硬盘。

​	数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

​	**用B+树不用B树**： 

- B树是每个索引节点都存有数据，B+树只有叶节点存放数据，其余节点用来索引，减少了磁盘I/O

- B+树 的特点就是每层节点数目非常多，层数很少，通常只有2或3层，目的就是为了减少磁盘IO次数。

- B+树所有的Data域在叶子节点，并且所有叶子节点都有一个指针指向相邻节点，更适合带范围的查找。

  而B树需要繁琐的中序遍历。

**用B+树不用红黑树**：

- 在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。而B树可以有多个子女，从几十到上千，可以降低树的高度，通常只有两三层高度。

### 最 左 前 缀 匹 配 原 则 了 解 么 ？ 

### 什么是覆盖索引 

### 一条 SQL 语句在 MySQL 中如何执行的？

### **explain** 命 令 了 解 么 ？ 

### 简单说一下 SQL 调优思路。

### 简单说一下大表优化的思路。 

### 分库分表了解么？为什么要分库分表？有哪些常见的分库分表工具( s h a r d i n g j d b c 、 T S h a r d i n g 、 M y C A T . . .)？ 

